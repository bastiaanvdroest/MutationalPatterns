%\VignetteIndexEntry{Introduction to MutationalPatterns}
\documentclass{article}
\usepackage{float}
\usepackage[natbibapa]{apacite}
\bibliographystyle{apacite}

\RequirePackage[]{/home/cog/bvanderroest/R/R-3.4.3/library/BiocStyle/resources/tex/Bioconductor2}
\usepackage[noae, nogin]{Sweave}
\title{Introduction to \Biocpkg{MutationalPatterns}}
\author{Francis Blokzijl}
\author{Roel Janssen}
\author{Bastiaan Van der Roest}
\author{Ruben van Boxtel}
\author{Edwin Cuppen}
\affil{University Medical Center Utrecht, Utrecht, The Netherlands}
\date{\today}

\usepackage{Sweave}
\begin{document} 
\input{Introduction_to_MutationalPatterns-concordance}

\maketitle

\tableofcontents

\newpage{}


\section{Introduction}

Mutational processes leave characteristic footprints in genomic DNA. This
package provides a comprehensive set of flexible functions that allows
researchers to easily evaluate and visualize a multitude of mutational patterns
in base substitution catalogues of e.g. tumour samples or DNA-repair deficient
cells. The package covers a wide range of patterns including: mutational
signatures, transcriptional and replicative strand bias, genomic distribution
and association with genomic features, which are collectively meaningful for
studying the activity of mutational processes. The package provides
functionalities for both extracting mutational signatures \emph{de novo} and
determining the contribution of previously identified mutational signatures on
a single sample level. MutationalPatterns integrates with common R genomic
analysis workflows and allows easy association with (publicly available)
annotation data.

Background on the biological relevance of the different mutational patterns, a
practical illustration of the package functionalities, comparison with similar
tools and software packages and an elaborate discussion, are described in the
MutationalPatterns article, which is published in Genome Medicine in 2018:
  \url{https://doi.org/10.1186/s13073-018-0539-0}

\newpage{}
\section{Data}

To perform the mutational pattern analyses, you need to load one or multiple
VCF files with substitutions and/or indel calls and the corresponding reference
genome.

\subsection{List reference genome}

List available genomes using \Biocpkg{BSgenome}:
  
\begin{Schunk}
\begin{Sinput}
> library(BSgenome)
> head(available.genomes())
\end{Sinput}
\begin{Soutput}
[1] "BSgenome.Alyrata.JGI.v1"                 "BSgenome.Amellifera.BeeBase.assembly4"  
[3] "BSgenome.Amellifera.UCSC.apiMel2"        "BSgenome.Amellifera.UCSC.apiMel2.masked"
[5] "BSgenome.Athaliana.TAIR.04232008"        "BSgenome.Athaliana.TAIR.TAIR9"          
\end{Soutput}
\end{Schunk}
  
Download and load your reference genome of interest:
  
\begin{Schunk}
\begin{Sinput}
> ref_genome <- "BSgenome.Hsapiens.UCSC.hg19"
> library(ref_genome, character.only = TRUE)
\end{Sinput}
\end{Schunk}
  
\subsection{Load example data}

We provided an example data set with this package, which consists of a subset of
somatic mutation catalogues of 9 normal human adult stem cells from 3 different
tissues \citep{Blokzijl2016}. When own data is loaded, please pay attention that
the files are in VCF format 4.2 or higher, which makes sure that all variants are 
loaded correctly.

Load the MutationalPatterns package:
  
\begin{Schunk}
\begin{Sinput}
> library(MutationalPatterns)
\end{Sinput}
\end{Schunk}


Locate the VCF files of the example data:
\begin{Schunk}
\begin{Sinput}
> vcf_files <- list.files(system.file("extdata", package="MutationalPatterns"),
+                         pattern = ".vcf", full.names = TRUE)
\end{Sinput}
\end{Schunk}


Define corresponding sample names for the VCF files:
\begin{Schunk}
\begin{Sinput}
> sample_names <- c(
+   "colon1", "colon2", "colon3",
+   "intestine1", "intestine2", "intestine3",
+   "liver1", "liver2", "liver3")
\end{Sinput}
\end{Schunk}

Load the VCF files into a \texttt{GRangesList}:
\begin{Schunk}
\begin{Sinput}
> vcfs <- read_vcfs_as_granges(vcf_files, sample_names, ref_genome)
> summary(vcfs)
\end{Sinput}
\begin{Soutput}
     Length       Class        Mode 
          9 GRangesList          S4 
\end{Soutput}
\end{Schunk}
  
Define relevant metadata on the samples, such as tissue type:
\begin{Schunk}
\begin{Sinput}
> tissue <- c(rep("colon", 3), rep("intestine", 3), rep("liver", 3))
\end{Sinput}
\end{Schunk}
  
  
\section{Mutation characteristics}

\subsection{Single base substitution types}

We can retrieve base substitutions from the VCF GRanges object as "REF>ALT"
using \Rfunction{mutations\_from\_vcf}:
  
\begin{Schunk}
\begin{Sinput}
> muts = mutations_from_vcf(vcfs[[1]])
> head(muts, 12)
\end{Sinput}
\begin{Soutput}
 [1] "G>A" "A>G" "G>A" "C>T" "T>A" "G>A" "C>T" "C>T" "C>A" "G>A" "T>C" "T>C"
\end{Soutput}
\end{Schunk}
  
We can retrieve the base substitutions from the VCF GRanges object and convert
them to the 6 types of base substitution types that are distinguished by
convention: C>A, C>G, C>T, T>A, T>C, T>G. For example, when the reference
allele is G and the alternative allele is T (G>T), \Rfunction{mut\_type}
returns the G:C>T:A mutation as a C>A mutation:
  
\begin{Schunk}
\begin{Sinput}
> types = mut_type(vcfs[[1]])
> head(types, 12)
\end{Sinput}
\begin{Soutput}
 [1] "C>T" "T>C" "C>T" "C>T" "T>A" "C>T" "C>T" "C>T" "C>A" "C>T" "T>C" "T>C"
\end{Soutput}
\end{Schunk}
  
To retrieve the sequence context (one base upstream and one base downstream) of
the single base substitutions in the VCF object from the reference genome, you can use
the \Rfunction{mut\_context} function:
  
\begin{Schunk}
\begin{Sinput}
> context = mut_context(vcfs[[1]], ref_genome)
> head(context, 12)
\end{Sinput}
\begin{Soutput}
 chr1  chr1  chr1  chr1  chr1  chr1  chr1  chr1  chr1  chr1  chr1  chr1 
"GGG" "GAC" "AGC" "ACC" "CTT" "GGA" "ACA" "ACA" "GCT" "GGA" "TTT" "TTT" 
\end{Soutput}
\end{Schunk}
  
With \Rfunction{type\_context}, you can retrieve the types and contexts
for all positions in the VCF GRanges object. For the base substitutions that are
converted to the conventional base substitution types, the reverse complement of
the sequence context is returned.

\begin{Schunk}
\begin{Sinput}
> type_context = type_context(vcfs[[1]], ref_genome)
> lapply(type_context, head, 12)
\end{Sinput}
\begin{Soutput}
$types
 [1] "C>T" "T>C" "C>T" "C>T" "T>A" "C>T" "C>T" "C>T" "C>A" "C>T" "T>C" "T>C"

$context
 chr1  chr1  chr1  chr1  chr1  chr1  chr1  chr1  chr1  chr1  chr1  chr1 
"CCC" "GTC" "GCT" "ACC" "CTT" "TCC" "ACA" "ACA" "GCT" "TCC" "TTT" "TTT" 
\end{Soutput}
\end{Schunk}
  
With \Rfunction{mut\_type\_occurrences}, you can count mutation type
occurrences for all VCF objects in the \texttt{GRangesList}. For
C>T mutations, a distinction is made between C>T at CpG sites and other
sites, as deamination of methylated cytosine at CpG sites is a common mutational
process. For this reason, the reference genome is needed for this functionality.

\begin{Schunk}
\begin{Sinput}
> type_occurrences <- mut_type_occurrences(vcfs, ref_genome)
> type_occurrences
\end{Sinput}
\begin{Soutput}
           C>A C>G C>T T>A T>C T>G C>T at CpG C>T other
colon1      32  21  94  20  51  13          6        88
colon2      50  16 111  32  71  30          7       104
colon3      52  18  91  43  66  25          4        87
intestine1  40  23  67  17  64  33          3        64
intestine2  17  18  48  13  43  17          0        48
intestine3  25  23  87  35  73  28          2        85
liver1      22  17  57  22  64  17          0        57
liver2      43  25 100  30  66  24          4        96
liver3      21  18  78  23  65  22          2        76
\end{Soutput}
\end{Schunk}

\subsection{Double base substitutions and indels}

Not only single base substitutions can be retrieved from the VCF GRanges object,
also double base substitutions and/or indels can be extracted,
if they are present in the loaded VCF files. Double base substitutions have the 
format "REF:NN > ALT:NN" or they are two SNVs with consecutive positions. Indels 
must be in at least VCF format 4.2. That means that deletions have a REF with 
the deletion length and an ALT with length 1, and insertions have a REF of 
length 1 and an ALT with the insertion length. Moreover, the REF and ALT of
indels only contains nucleotide letters (A, C, G and T), no other characters.

These two types of mutations are retrieved the same way as the single base 
substitutions: "REF>ALT", using \Rfunction{mutations\_from\_vcf}. 
Therefore set the argument \texttt{type} to a vector of the wanted mutation
types. When multiple mutation types are requested, the output will be a list of 
mutation types.\\
  
\begin{Schunk}
\begin{Sinput}
> muts = mutations_from_vcf(vcfs[[1]], type = c("dbs", "indel"))
> lapply(muts, head, 12)
\end{Sinput}
\begin{Soutput}
$dbs
character(0)

$indel
 [1] "CA>C"                                    "TGGAG>T"                                
 [3] "CTCT>C"                                  "AAAGAAGAAGAAG>A"                        
 [5] "G>GTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT" "A>ATTTC"                                
 [7] "G>GTT"                                   "TGCACA>T"                               
 [9] "G>GAGGCCGGGC"                            "C>CCCCTCTTTCTCATTTTTCTTCTTAAAGGTTGGTG"  
[11] "T>TGTTGTTG"                              "TA>T"                                   
\end{Soutput}
\end{Schunk}

To convert the double base substitutions to the 78 strand-agnostic types found
in the COSMIC database, run the function \Rfunction{mut\_type}. The 1 basepair
indels will also be converted to a "C" or "T" indel with this function:

\begin{Schunk}
\begin{Sinput}
> types = mut_type(vcfs[[1]], type = c("dbs", "indel"))
> lapply(types, head, 12)
\end{Sinput}
\begin{Soutput}
$dbs
character(0)

$indel
 [1] "CA>C"                                    "TGGAG>T"                                
 [3] "CTCT>C"                                  "AAAGAAGAAGAAG>A"                        
 [5] "G>GTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT" "A>ATTTC"                                
 [7] "G>GTT"                                   "TGCACA>T"                               
 [9] "G>GAGGCCGGGC"                            "C>CCCCTCTTTCTCATTTTTCTTCTTAAAGGTTGGTG"  
[11] "T>TGTTGTTG"                              "TA>T"                                   
\end{Soutput}
\end{Schunk}

The insertions and deletions can be translated to a more clear definition, on
which the indels can be grouped. Since there is no single intuitive and 
naturally constrained set of indel mutation types, it is possible to give
an own definition of indels and to set global variables for this definition.
For this the function \Rfunction{indel\_mutation\_type} can be used. To set 
the indel context following the COSMIC database, use:

\begin{Schunk}
\begin{Sinput}
> indel_mutation_type("cosmic")
\end{Sinput}
\end{Schunk}

Then the indel mutations can be translated with \Rfunction{mut\_context}:

\begin{Schunk}
\begin{Sinput}
> context = mut_context(vcfs[[1]], ref_genome, type = "indel", indel = "cosmic")
> head(context, 12)
\end{Sinput}
\begin{Soutput}
 [1] "del.1bp.homopol.T.len.2" "del.rep.len.4.rep.1"     "del.rep.len.3.rep.1"    
 [4] "del.mh.len.5+.bimh.5+"   "ins.rep.len.5+.rep.0"    "ins.rep.len.4.rep.2"    
 [7] "ins.rep.len.2.rep.0"     "del.rep.len.5+.rep.1"    "ins.rep.len.5+.rep.0"   
[10] "ins.rep.len.5+.rep.0"    "ins.rep.len.5+.rep.0"    "del.1bp.homopol.T.len.1"
\end{Soutput}
\end{Schunk}

As with the single base substitutions, \Rfunction{type\_context} can be used
to retrieve type and context information of all double base substitutions, 
insertions and deletions. The function will return the type and context 
information as a list of mutation types:

\begin{Schunk}
\begin{Sinput}
> type_context = type_context(vcfs[[1]], ref_genome, type = c("dbs","indel"))
> lapply(type_context, function(x) lapply(x, head, 10))
\end{Sinput}
\begin{Soutput}
$dbs
$dbs$types
NULL

$dbs$context
NULL


$indel
$indel$types
 [1] "CA>C"                                    "TGGAG>T"                                
 [3] "CTCT>C"                                  "AAAGAAGAAGAAG>A"                        
 [5] "G>GTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT" "A>ATTTC"                                
 [7] "G>GTT"                                   "TGCACA>T"                               
 [9] "G>GAGGCCGGGC"                            "C>CCCCTCTTTCTCATTTTTCTTCTTAAAGGTTGGTG"  

$indel$context
 [1] "del.1bp.homopol.T.len.2" "del.rep.len.4.rep.1"     "del.rep.len.3.rep.1"    
 [4] "del.mh.len.5+.bimh.5+"   "ins.rep.len.5+.rep.0"    "ins.rep.len.4.rep.2"    
 [7] "ins.rep.len.2.rep.0"     "del.rep.len.5+.rep.1"    "ins.rep.len.5+.rep.0"   
[10] "ins.rep.len.5+.rep.0"   
\end{Soutput}
\end{Schunk}

\subsection{Mutation spectrum}

A mutation spectrum shows the relative contribution of each mutation type in
the base substitution catalogs. The \Rfunction{plot\_spectrum} function plots
the mean relative contribution of each of the 6 base substitution types over
all samples. Error bars indicate standard deviation over all samples. The total
number of mutations is indicated.

\begin{Schunk}
\begin{Sinput}
> p1 <- plot_spectrum(type_occurrences)
\end{Sinput}
\end{Schunk}
  
Plot the mutation spectrum with distinction
between C>T at CpG sites and other sites:
  
\begin{Schunk}
\begin{Sinput}
> p2 <- plot_spectrum(type_occurrences, CT = TRUE)
\end{Sinput}
\end{Schunk}
  
Plot spectrum without legend:
\begin{Schunk}
\begin{Sinput}
> p3 <- plot_spectrum(type_occurrences, CT = TRUE, legend = FALSE)
\end{Sinput}
\end{Schunk}
  
The gridExtra package will be used throughout this vignette to combine multiple
plots:
\begin{Schunk}
\begin{Sinput}
> library("gridExtra")
> grid.arrange(p1, p2, p3, ncol=3, widths=c(3,3,1.75))
\end{Sinput}
\end{Schunk}
  
\begin{figure}[H]
\begin{center}
\includegraphics[width=1.0\textwidth]{combine_plot_spectrum}
\end{center}
\end{figure}

You can facet the per sample group, e.g. plot the spectrum for each tissue
separately:
\begin{Schunk}
\begin{Sinput}
> p4 <- plot_spectrum(type_occurrences, by = tissue, CT = TRUE, legend = TRUE)
\end{Sinput}
\end{Schunk}
  
Define your own 7 colors for spectrum plotting:
\begin{Schunk}
\begin{Sinput}
> palette <- c("pink", "orange", "blue", "lightblue", "green", "red", "purple")
> p5 <- plot_spectrum(type_occurrences, CT=TRUE, legend=TRUE, colors=palette)
\end{Sinput}
\end{Schunk}
  
  
\begin{Schunk}
\begin{Sinput}
> grid.arrange(p4, p5, ncol=2, widths=c(4,2.3))
\end{Sinput}
\end{Schunk}
  
\begin{figure}[H]
\begin{center}
\includegraphics[width=1.0\textwidth]{combine_plot_spectrum_2}
\end{center}
\end{figure}

\subsection{96 mutational profile}

Make a 96 trinucleodide mutation count matrix:
\begin{Schunk}
\begin{Sinput}
> mut_mat <- mut_matrix(vcf_list = vcfs, ref_genome = ref_genome)
\end{Sinput}
\begin{Soutput}
[1] "snv"
\end{Soutput}
\begin{Sinput}
> head(mut_mat)
\end{Sinput}
\begin{Soutput}
        colon1 colon2 colon3 intestine1 intestine2 intestine3 liver1 liver2 liver3
A[C>A]A      6     13     12          6          3          4      7      7      4
A[C>A]C      2      3      3          0          1          0      0      3      0
A[C>A]G      1      1      2          1          0          0      0      0      1
A[C>A]T      0      3      3          1          1          3      0      2      0
C[C>A]A      2      4      5          4          2          2      1      6      0
C[C>A]C      2      3      1          7          1          3      2      4      6
\end{Soutput}
\end{Schunk}
  
Plot the 96 profile of two samples:
\begin{Schunk}
\begin{Sinput}
> plot_profiles(mut_mat[,c(1,7)])
\end{Sinput}
\end{Schunk}

  
\begin{figure}[H]
\begin{center}
\includegraphics[width=1.0\textwidth]{plot_96_profile_2}
\end{center}
\end{figure}

Plot 96 profile of two samples in a more condensed plotting format:
\begin{Schunk}
\begin{Sinput}
> plot_profiles(mut_mat[,c(1,7)], condensed = TRUE)
\end{Sinput}
\end{Schunk}
  
  
\begin{figure}[H]
\begin{center}
\includegraphics[width=1.0\textwidth]{plot_96_profile_3}
\end{center}
\end{figure}

\subsection{Plot mutation profiles of different types}

To plot the mutation profiles of different mutation types (SBS, DBS
and/or indels), first make a list of mutation count matrices:

\begin{Schunk}
\begin{Sinput}
> mut_mat <- mut_matrix(vcf_list = vcfs, ref_genome = ref_genome, type = "all")
> lapply(mut_mat, head)
\end{Sinput}
\begin{Soutput}
$snv
        colon1 colon2 colon3 intestine1 intestine2 intestine3 liver1 liver2 liver3
A[C>A]A      6     13     12          6          3          4      7      7      4
A[C>A]C      2      3      3          0          1          0      0      3      0
A[C>A]G      1      1      2          1          0          0      0      0      1
A[C>A]T      0      3      3          1          1          3      0      2      0
C[C>A]A      2      4      5          4          2          2      1      6      0
C[C>A]C      2      3      1          7          1          3      2      4      6

$dbs
      colon1 colon2 colon3 intestine1 intestine2 intestine3 liver1 liver2 liver3
AC>CA      0      0      0          0          0          0      0      0      0
AC>CG      0      0      0          0          0          0      0      0      0
AC>CT      0      0      0          0          0          0      0      0      0
AC>GA      0      0      0          0          0          0      0      0      0
AC>GG      0      0      0          0          0          0      0      0      0
AC>GT      0      0      0          0          0          0      0      0      0

$indel
                         colon1 colon2 colon3 intestine1 intestine2 intestine3 liver1 liver2
del.1bp.homopol.C.len.1       2     11      9          9          9         12      9     12
del.1bp.homopol.C.len.2       2      3      2          1          3          4      1      2
del.1bp.homopol.C.len.3       0      2      2          0          0          1      1      1
del.1bp.homopol.C.len.4       0      0      0          0          0          1      0      1
del.1bp.homopol.C.len.5       0      0      1          0          0          0      0      1
del.1bp.homopol.C.len.6+      0      0      1          0          0          0      0      1
                         liver3
del.1bp.homopol.C.len.1      14
del.1bp.homopol.C.len.2       2
del.1bp.homopol.C.len.3       4
del.1bp.homopol.C.len.4       1
del.1bp.homopol.C.len.5       1
del.1bp.homopol.C.len.6+      0
\end{Soutput}
\end{Schunk}

Make a list of two samples:
\begin{Schunk}
\begin{Sinput}
> mut_mat_sub <- list("snv" = mut_mat$snv[,c(1,7)],
+                     "dbs" = mut_mat$dbs[,c(1,7)],
+                     "indel" = mut_mat$indel[,c(1,7)])
\end{Sinput}
\end{Schunk}

Plot the mutation profiles of the two samples:
\begin{Schunk}
\begin{Sinput}
> plot_profiles(mut_mat_sub, type = "all")
\end{Sinput}
\end{Schunk}


\begin{figure}[H]
\begin{center}
\includegraphics[width=1.0\textwidth]{plot_profiles_2}
\end{center}
\end{figure}

It is also possible to plot mutation profiles with all mutation types
together.

\begin{Schunk}
\begin{Sinput}
> plot_profiles(mut_mat_sub, type = "all", method = "combine")
\end{Sinput}
\end{Schunk}


\begin{figure}[H]
\begin{center}
\includegraphics[width=1.0\textwidth]{plot_profiles_3}
\end{center}
\end{figure}

\newpage{}
\section{Mutational signatures}

\subsection{\textit{De novo} mutational signature extraction using NMF}

Mutational signatures are thought to represent mutational processes, and are
characterized by a specific contribution of 96 single base substitution types,
78 double bas substitutions types or indels. Mutational signatures can be
extracted from your mutation count matrix, with non-negative matrix
factorization (NMF). A critical parameter in NMF is the factorization rank,
which is the number of mutational signatures. You can determine the optimal
factorization rank using the NMF package \citep{Gaujoux2010}. As described in
their paper:

``...a common
way of deciding on the rank is to try different values, compute some quality
measure of the results, and choose the best value according to this quality
criteria. The most common approach is to choose the smallest rank for which
cophenetic correlation coefficient starts decreasing. Another approach is to
choose the rank for which the plot of the residual sum of squares (RSS) between
the input matrix and its estimate shows an inflection point.''

Lets start with the single base substitutions. First add a small psuedocount
to your mutation count matrix, such that there are no rows where the sum of
the row is zero:

\begin{Schunk}
\begin{Sinput}
> mut_mat <- mut_matrix(vcf_list = vcfs, ref_genome = ref_genome)
> mut_mat <- mut_mat + 0.0001
\end{Sinput}
\end{Schunk}

Use the NMF package to generate an estimate rank plot:
\begin{Schunk}
\begin{Sinput}
> library("NMF")
> estimate <- nmf(mut_mat, rank=2:5, method="brunet", nrun=10, seed=123456)
\end{Sinput}
\end{Schunk}

And plot it:
\begin{Schunk}
\begin{Sinput}
> plot(estimate)
\end{Sinput}
\end{Schunk}


\begin{figure}[H]
\begin{center}
\includegraphics[width=1.0\textwidth]{estimate_rank}
\end{center}
\end{figure}

Extract 2 mutational signatures from the mutation count matrix with
\Rfunction{extract\_signatures} (For larger datasets it is wise to perform more
iterations by changing the nrun parameter to achieve stability and avoid local
minima):

\begin{Schunk}
\begin{Sinput}
> nmf_res <- extract_signatures(mut_mat, rank = 2, nrun = 10)
\end{Sinput}
\end{Schunk}

Assign signature names:
\begin{Schunk}
\begin{Sinput}
> colnames(nmf_res$signatures) <- c("Signature A", "Signature B")
> rownames(nmf_res$contribution) <- c("Signature A", "Signature B")
\end{Sinput}
\end{Schunk}

Plot the 96-profile of the signatures:
\begin{Schunk}
\begin{Sinput}
> plot_profiles(nmf_res$signatures, condensed = TRUE)
\end{Sinput}
\end{Schunk}


\begin{figure}[H]
\begin{center}
\includegraphics[width=1.0\textwidth]{plot_profiles}
\end{center}
\end{figure}

In order to extract signatures for all mutation types at once, make a list of 
mutation matrices for each mutation type:

\begin{Schunk}
\begin{Sinput}
> mut_mat <- mut_matrix(vcf_list = vcfs, ref_genome = ref_genome, type = "all")
> mut_mat <- lapply(mut_mat, function(x) x + 0.0001)
\end{Sinput}
\end{Schunk}

Generate a estimate rank plot with the NMF package for each mutation type and
find the best ranks. Extract then the signatures from the mutation matrices
with \Rfunction{extract\_signatures}. Use \texttt{type = "all"} to get all
mutation types.

\begin{Schunk}
\begin{Sinput}
> nmf_res <- extract_signatures(mut_mat,
+                               rank = c("snv" = 2, "dbs" = 2, "indel" = 2),
+                               type = "all",
+                               nrun = 10)
\end{Sinput}
\end{Schunk}

Assign signature names
\begin{Schunk}
\begin{Sinput}
> colnames(nmf_res$signatures$snv) <- c("SBS A", "SBS B")
> colnames(nmf_res$signatures$dbs) <- c("DBS A", "DBS B")
> colnames(nmf_res$signatures$indel) <- c("INDEL A", "INDEL B")
> rownames(nmf_res$contribution$snv) <- c("SBS A", "SBS B")
> rownames(nmf_res$contribution$dbs) <- c("DBS A", "DBS B")
> rownames(nmf_res$contribution$indel) <- c("INDEL A", "INDEL B")
\end{Sinput}
\end{Schunk}

Plot the profiles of the signatures:
\begin{Schunk}
\begin{Sinput}
> plot_profiles(nmf_res$signatures, condensed = TRUE, type = "all")
\end{Sinput}
\end{Schunk}


\begin{figure}[H]
\begin{center}
\includegraphics[width=1.0\textwidth]{plot_profiles_all}
\end{center}
\end{figure}

Visualize the contribution of the SBS signatures in a barplot:
\begin{Schunk}
\begin{Sinput}
> pc1 <- plot_contribution(nmf_res$contribution, nmf_res$signature,
+                          mode = "relative")
\end{Sinput}
\end{Schunk}

Visualize the contribution of the signatures in absolute number of mutations:
\begin{Schunk}
\begin{Sinput}
> pc2 <- plot_contribution(nmf_res$contribution, nmf_res$signature,
+                          mode = "absolute")
\end{Sinput}
\end{Schunk}

Combine the two plots:
\begin{Schunk}
\begin{Sinput}
> grid.arrange(pc1, pc2)
\end{Sinput}
\end{Schunk}


\begin{figure}[H]
\begin{center}
\includegraphics[width=1.0\textwidth]{plot_contribution2_fig}
\end{center}
\end{figure}

Flip X and Y coordinates:

\begin{Schunk}
\begin{Sinput}
> plot_contribution(nmf_res$contribution, nmf_res$signature,
+                          mode = "absolute", coord_flip = TRUE)
\end{Sinput}
\end{Schunk}


\begin{figure}[H]
\begin{center}
\includegraphics[width=1.0\textwidth]{plot_contribution_4}
\end{center}
\end{figure}

To visualize the contribution of the signatures for all mutation types
in both relative and absolute number of mutations, set 
\texttt{type = "all"} and \texttt{mode = "both"}:

\begin{Schunk}
\begin{Sinput}
> plot_contribution(nmf_res$contribution, nmf_res$signature,
+                  type = "all", mode = "both")
\end{Sinput}
\end{Schunk}



\begin{figure}[H]
\begin{center}
\includegraphics[width=1.0\textwidth]{plot_contribution_all}
\end{center}
\end{figure}

The relative contribution of each signature for each sample can also be plotted
as a heatmap with \Rfunction{plot\_contribution\_heatmap}, which might be easier
to interpret and compare than stacked barplots. The samples can be
hierarchically clustered based on their euclidean distance. The signatures can
be plotted in a user-specified order.

Plot SBS signature contribution as a heatmap with sample clustering dendrogram and
a specified signature order:

\begin{Schunk}
\begin{Sinput}
> pch1 <- plot_contribution_heatmap(nmf_res$contribution,
+                                   sig_order = c("SBS B", "SBS A"))
\end{Sinput}
\end{Schunk}

Plot SBS signature contribution as a heatmap without sample clustering:
\begin{Schunk}
\begin{Sinput}
> pch2 <- plot_contribution_heatmap(nmf_res$contribution, cluster_samples=FALSE)
\end{Sinput}
\end{Schunk}

Combine the plots into one figure:
\begin{Schunk}
\begin{Sinput}
> grid.arrange(pch1, pch2, ncol = 2, widths = c(2,1.6))
\end{Sinput}
\end{Schunk}


\begin{figure}[H]
\begin{center}
\includegraphics[width=1.0\textwidth]{plot_contribution_heatmap2.pdf}
\end{center}
\end{figure}

When plotting the signature contribution of multiple mutation types, it is
possible to cluster on a specified mutation type. The mutation type(s) on
which the data will be clustered, will show up at the left side of the heatmap.
Plot the signature contribution, clustered by DBS signatures, by setting
\texttt{cluster\_mut\_type = "dbs"}:

\begin{Schunk}
\begin{Sinput}
> plot_contribution_heatmap(nmf_res$contribution, type = "all",
+                           cluster_mut_type = "dbs",
+                           plot_values = TRUE)
\end{Sinput}
\end{Schunk}


\begin{figure}[H]
\begin{center}
\includegraphics[width=1.0\textwidth]{plot_contribution_heatmap_all}
\end{center}
\end{figure}

In order to see the performance of the NMF algorithm, a reconstruction 
of the count matrices are given by \Rfunction{extract\_signatures}.
Compare a reconstructed 96 mutational profile of SNVs with the original 
96 mutational profile of SNVs:

\begin{Schunk}
\begin{Sinput}
> plot_compare_profiles(mut_mat$snv[,1],
+                         nmf_res$snv$reconstructed[,1],
+                         profile_names = c("Original", "Reconstructed"),
+                         condensed = TRUE)
\end{Sinput}
\end{Schunk}


\begin{figure}[H]
\begin{center}
\includegraphics[width=1.0\textwidth]{plot_compare_profiles}
\end{center}
\end{figure}

\subsection{Find optimal contribution of known signatures}

\subsubsection{COSMIC mutational signatures}

Download mutational signatures from the COSMIC website. As there are 
multiple versions of the signatures, this vignette uses the signatures from
COSMIC version 3 for SBS, DBS and indels. These signatures are available in
numerical form from synapse.org ID syn12009743. Download here the referece
whole genome signatures. Then load as follow:

% <<download_cancer_signatures>>=
% sp_url <- paste("https://cancer.sanger.ac.uk/cancergenome/assets/",
%                 "signatures_probabilities.txt", sep = "")
% 
% snv_signatures = read.table(sp_url, sep = "\t", header = TRUE)
% # Match the order of the mutation types to MutationalPatterns standard
% new_order = match(row.names(mut_mat$snv), snv_signatures$Somatic.Mutation.Type)
% # Reorder cancer signatures dataframe
% snv_signatures = snv_signatures[as.vector(new_order),]
% # Add trinucletiode changes names as row.names
% row.names(snv_signatures) = snv_signatures$Somatic.Mutation.Type
% # Keep only 96 contributions of the signatures in matrix
% snv_signatures = as.matrix(snv_signatures[,4:33])
% @
 
\begin{Schunk}
\begin{Sinput}
> # Read the SBS signatures file
> snv_signatures = read.csv("sigProfiler_SBS_signatures_v3_2019_05_22.csv")
> # Derive the 96 mutations
> snv_signatures$MutationType = sprintf("%s[%s]%s",
+                                       substr(snv_signatures$SubType, 1, 1),
+                                       snv_signatures$Type,
+                                       substr(snv_signatures$SubType, 3, 3))
> # Match the order of the mutation types to MutationalPatterns standard
> new_order = match(row.names(mut_mat$snv), snv_signatures$MutationType)
> # Reorder cancer signatures dataframe
> snv_signatures = snv_signatures[as.vector(new_order),]
> # Add trinucletiode changes names as row.names
> row.names(snv_signatures) = snv_signatures$MutationType
> # Keep only 96 contributions of the signatures in matrix
> snv_signatures = as.matrix(snv_signatures[,3:69])
> # Read the DBS signatures file
> dbs_signatures = read.csv("sigProfiler_DBS_signatures.csv")
> # Add mutation types as rownames
> rownames(dbs_signatures) = dbs_signatures$Mutation.Type
> # Keep only 10 DBS signatures
> dbs_signatures = as.matrix(dbs_signatures[,2:11])
> # Read the indel signatures file
> indel_signatures = read.csv("sigProfiler_ID_signatures.csv")
> # Add indel context as rownames
> rownames(indel_signatures) = INDEL_COSMIC
> # Keep only the 17 indel signatures
> indel_signatures = as.matrix(indel_signatures[,2:18])
> # Store all mutation types in one list
> cancer_signatures = list("snv" = snv_signatures,
+                          "dbs" = dbs_signatures,
+                          "indel" = indel_signatures)
\end{Sinput}
\end{Schunk}


Plot mutational profile of the first two COSMIC SBS signatures:
\begin{Schunk}
\begin{Sinput}
> plot_profiles(cancer_signatures$snv[,1:2], condensed = TRUE, ymax = "maximum")
\end{Sinput}
\end{Schunk}


\begin{figure}[H]
\begin{center}
\includegraphics[width=1.0\textwidth]{plot_profiles_COSMIC}
\end{center}
\end{figure}

Hierarchically cluster the COSMIC SBS signatures based on their similarity with
average linkage:

\begin{Schunk}
\begin{Sinput}
> hclust_cosmic = cluster_signatures(cancer_signatures$snv, method = "average")
> # store signatures in new order
> cosmic_order = colnames(cancer_signatures$snv)[hclust_cosmic$order]
> plot(hclust_cosmic)
\end{Sinput}
\end{Schunk}


\begin{figure}[H]
\begin{center}
\includegraphics[width=1.0\textwidth]{cluster_COSMIC}
\end{center}
\end{figure}

The same can be done for DBS and indel signatures, by changing the 
\texttt{type} argument to "all".

\subsubsection{Similarity between mutational profiles and COSMIC signatures}

The similarity between each mutational profile and each COSMIC signature, can be
calculated with \Rfunction{cos\_sim\_matrix}, and visualized with
\Rfunction{plot\_cosine\_heatmap}. The cosine similarity reflects how well each
mutational profile can be explained by each signature individually. The
advantage of this heatmap representation is that it shows in a glance the
similarity in mutational profiles between samples, while at the same time
providing information on which signatures are most prominent. The samples can be
hierarchically clustered in \Rfunction{plot\_cosine\_heatmap}.

The cosine similarity between two mutational profiles/signatures can be
calculated with \Rfunction{cos\_sim}:

\begin{Schunk}
\begin{Sinput}
> cos_sim(mut_mat$snv[,1], cancer_signatures$snv[,1])
\end{Sinput}
\begin{Soutput}
[1] 0.5200306
\end{Soutput}
\end{Schunk}

To do pairwise cosine similarity calculations of mutational profiles and COSMIC
signatures, use the function \Rcode{cos\_sim\_matrix}:

\begin{Schunk}
\begin{Sinput}
> cos_sim_samples_signatures = cos_sim_matrix(mut_mat, cancer_signatures,
+                                             type = "all")
> lapply(cos_sim_samples_signatures, function(x) x[1:5,1:5])
\end{Sinput}
\begin{Soutput}
$snv
                SBS1      SBS2      SBS3      SBS4      SBS5
colon1     0.5200306 0.2808230 0.6265106 0.3595018 0.8033183
colon2     0.3560223 0.2081480 0.7033546 0.4101365 0.8429317
colon3     0.2912627 0.2118448 0.7493105 0.4720767 0.8320451
intestine1 0.2029325 0.2538327 0.7557348 0.4460553 0.8131116
intestine2 0.3279535 0.2887903 0.6996420 0.3559883 0.8097798

$dbs
                   DBS1         DBS2       DBS3        DBS4        DBS5
colon1     0.1317944889 0.1540164590 0.41113692 0.221113429 0.217078507
colon2     0.0004411857 0.0003319059 0.05806684 0.001765877 0.001104112
colon3     0.1317944889 0.1540164590 0.41113692 0.221113429 0.217078507
intestine1 0.1317944889 0.1540164590 0.41113692 0.221113429 0.217078507
intestine2 0.1317944889 0.1540164590 0.41113692 0.221113429 0.217078507

$indel
                  ID1         ID2        ID3        ID4       ID5
colon1     0.19892691 0.029872747 0.09543576 0.06543478 0.2342998
colon2     0.04072494 0.003110931 0.10458474 0.09354174 0.1511328
colon3     0.05180514 0.037694816 0.13848620 0.13572804 0.2128697
intestine1 0.37721882 0.367938627 0.13381263 0.11116837 0.2683759
intestine2 0.27748826 0.312236672 0.15130223 0.16146751 0.2404568
\end{Soutput}
\end{Schunk}

Plot the cosine similarity heatmap of the SBS signatures:

\begin{Schunk}
\begin{Sinput}
> plot_cosine_heatmap(cos_sim_samples_signatures$snv,
+                     cluster_rows = TRUE)
\end{Sinput}
\end{Schunk}


\begin{figure}[H]
\begin{center}
\includegraphics[width=1.0\textwidth]{plot_cosine_heatmap}
\end{center}
\end{figure}

\subsubsection{Find optimal contribution of COSMIC signatures to reconstruct mutational profiles}

In addition to \textit{de novo} extraction of signatures, the contribution of
any set of signatures to the mutational profile of a sample can be quantified.
This unique feature is specifically useful for mutational signature analyses of
small cohorts or individual samples, but also to relate own findings to known
signatures and published findings. The  \Rfunction{fit\_to\_signatures} function
has two options to find the optimal linear combination of mutational signatures
that most closely reconstructs the mutation matrix: solving a non-negative
least-squares constraints problem and performing a golden ratio search (as
implemented in the deconstructSigs package from Rosenthal et al.
\citep{Rosenthal2016}). The default option is the non-negative least-squares
problem.

First get new mutation matrices, without the 0.001 used by the NMF estimation:

\begin{Schunk}
\begin{Sinput}
> mut_mat <- mut_matrix(vcf_list = vcfs, ref_genome, type = "all")
\end{Sinput}
\end{Schunk}

Fit mutation matrices to the COSMIC signatures:

\begin{Schunk}
\begin{Sinput}
> fit_res <- fit_to_signatures(mut_mat, cancer_signatures, type = "all")
\end{Sinput}
\end{Schunk}

Plot the optimal contribution of the COSMIC signatures in each sample as a
stacked barplot.

\begin{Schunk}
\begin{Sinput}
> # Select signatures with some contribution
> fit_res$contribution$snv <- fit_res$contribution$snv[
+   which(rowSums(fit_res$contribution$snv) > 100),]
> fit_res$contribution$dbs <- fit_res$contribution$dbs[
+   which(rowSums(fit_res$contribution$dbs) > 0.1),]
> fit_res$contribution$indel <- fit_res$contribution$indel[
+   which(rowSums(fit_res$contribution$indel) > 10),]
> # Plot contribution barplot
> plot_contribution(fit_res$contribution,
+                     cancer_signatures,
+                     coord_flip = FALSE,
+                     mode = "absolute")
\end{Sinput}
\end{Schunk}


\begin{figure}[H]
\begin{center}
\includegraphics[width=1.0\textwidth]{plot_contribution_3}
\end{center}
\end{figure}

Results of the golden ratio search algorithm are only relative, so fit
the mutation matrix with the golden ratio search and plot results from
both methods in relative contribution:

\begin{Schunk}
\begin{Sinput}
> fit_res_grs <- fit_to_signatures(mut_mat, cancer_signatures, type = "snv",
+                              method = "golden-ratio-search")
> # Select signatures with some contribution
> select_grs <- which(rowSums(fit_res_grs$contribution) > 0.06)
\end{Sinput}
\end{Schunk}

In order to match colors when \Rfunction{plot\_contribution} is run for both
the non-negative least squares problem and the golden ratio search, make a 
palette of colors with the \n \Rfunction{default\_colors\_ggplot} function:

\begin{Schunk}
\begin{Sinput}
> colorvector <- default_colors_ggplot(ncol(cancer_signatures$snv))
\end{Sinput}
\end{Schunk}

Then plot the results of both algorithms:

\begin{Schunk}
\begin{Sinput}
> # Plot relative contribution from non-negative least squares
> select = match(rownames(fit_res$contribution$snv), colnames(cancer_signatures$snv))
> pc1 <- plot_contribution(fit_res$contribution,
+                    cancer_signatures$snv,
+                    coord_flip = FALSE,
+                    type = "snv",
+                    mode = "relative",
+                    palette = list("snv" = colorvector[select]))
> # Plot relative contribution from golden ratio search
> pc2 <- plot_contribution(fit_res_grs$contribution[select_grs,],
+                         cancer_signatures$snv[,select_grs],
+                         coord_flip = FALSE,
+                         mode = "relative",
+                         palette = list("snv" = colorvector[select_grs]))
\end{Sinput}
\end{Schunk}


\begin{figure}[H]
\begin{center}
\includegraphics[width=1.0\textwidth]{plot_contribution_nnls_grs}
\end{center}
\end{figure}

% 
% \begin{figure}[H]
% \begin{center}
% <<plot_contribution_heatmap3, fig=TRUE, width=8, height=3, echo=FALSE>>=
% plot_contribution_heatmap(fit_res$contribution,
%                           cluster_samples = TRUE,
%                           method = "complete")
% @
% \end{center}
% \end{figure}
% 
% Compare the reconstructed mutational profile of sample 1
% with its original mutational profile:
% <<plot_compare_profiles_2_e, eval=FALSE>>=
% plot_compare_profiles(mut_mat$snv[,1], fit_res$reconstructed[,1],
%                         profile_names = c("Original", "Reconstructed"),
%                         condensed = TRUE)
% @
% 
% \begin{figure}[H]
% \begin{center}
% <<plot_compare_profiles_2, fig=TRUE, width=6, height=5.5, echo=FALSE>>=
% plot_compare_profiles(mut_mat$snv[,1], fit_res$reconstructed[,1],
%                         profile_names = c("Original", "Reconstructed"),
%                         condensed = TRUE)
% @
% \end{center}
% \end{figure}
% 
% Calculate the cosine similarity between all original and reconstructed
% mutational profiles with \Rfunction{cos\_sim\_matrix}:
% 
% <<cos_sim_ori_rec>>=
% # calculate all pairwise cosine similarities
% cos_sim_ori_rec <- cos_sim_matrix(mut_mat$snv, fit_res$reconstructed)
% # extract cosine similarities per sample between original and reconstructed
% cos_sim_ori_rec <- as.data.frame(diag(cos_sim_ori_rec))
% @
% 
% We can use ggplot to make a barplot of the cosine similarities between the
% original and reconstructed mutational profile of each sample. This clearly
% shows how well each mutational profile can be reconstructed with the COSMIC
% mutational signatures. Two identical profiles have a cosine similarity of 1.
% The lower the cosine similarity between original and reconstructed, the less
% well the original mutational profile can be reconstructed with the COSMIC
% signatures. You could use, for example, cosine similarity of 0.95 as a cutoff.
% 
% <<cos_sim_ori_rec>>=
% # Adjust data frame for plotting with gpplot
% colnames(cos_sim_ori_rec) = "cos_sim"
% cos_sim_ori_rec$sample = row.names(cos_sim_ori_rec)
% @
% 
% <<plot_cos_sim_ori_rec_e, eval=FALSE>>=
% # Load ggplot2
% library(ggplot2)
% # Make barplot
% ggplot(cos_sim_ori_rec, aes(y=cos_sim, x=sample)) +
%   geom_bar(stat="identity", fill = "skyblue4") +
%   coord_cartesian(ylim=c(0.8, 1)) +
%   # coord_flip(ylim=c(0.8,1)) +
%   ylab("Cosine similarity\n original VS reconstructed") +
%   xlab("") +
%   # Reverse order of the samples such that first is up
%   # xlim(rev(levels(factor(cos_sim_ori_rec$sample)))) +
%   theme_bw() +
%   theme(panel.grid.minor.y=element_blank(),
%         panel.grid.major.y=element_blank()) +
%   # Add cut.off line
%   geom_hline(aes(yintercept=.95))
% @
% 
% \begin{figure}[H]
% \begin{center}
% <<plot_cos_sim_ori_rec, fig=TRUE, width=6, height=3, echo=FALSE>>=
% # Load ggplot2
% library(ggplot2)
% # Make barplot
% ggplot(cos_sim_ori_rec, aes(y=cos_sim, x=sample)) +
%   geom_bar(stat="identity", fill = "skyblue4") +
%   coord_cartesian(ylim=c(0.8, 1)) +
%   # coord_flip(ylim=c(0.8,1)) +
%   ylab("Cosine similarity\n original VS reconstructed") +
%   xlab("") +
%   # Reverse order of the samples such that first is up
%   # xlim(rev(levels(factor(cos_sim_ori_rec$sample)))) +
%   theme_bw() +
%   theme(panel.grid.minor.y=element_blank(),
%         panel.grid.major.y=element_blank()) +
%   # Add cut.off line
%   geom_hline(aes(yintercept=.95))
% @
% \end{center}
% \end{figure}
% 
% \section{Strand bias analyses}
% 
% \subsection{Transcriptional strand bias analysis}
% 
% For the mutations within genes it can be determined whether the mutation is
% on the transcribed or non-transcribed strand, which can be used to evaluate
% the involvement of transcription-coupled repair. To this end, it is determined
% whether the "C" or "T" base (since by convention we regard base substitutions
% as C>X or T>X) are on the same strand as the gene definition. Single base
% substitions on the same strand as the gene definitions are considered
% "untranscribed", and on the opposite strand of gene bodies as "transcribed",
% since the gene definitions report the coding or sense strand, which is
% untranscribed. No strand information is reported for base substitution that
% overlap with more than one gene body on different strands.
% 
% Alike the single base substitutions, double base substitutions are
% converted to defined set of double bases. These bases are either on the same
% strand as a gene definition, consider them "untranscribed", or on the other
% strand, consider them "transcribed". Indels do not have such a conversion,
% therefore losing strand information based on mutations.
% 
% Get gene definitions for your reference genome:
% 
% <<get_genes>>=
% # For example get known genes table from UCSC for hg19 using
% # biocLite("TxDb.Hsapiens.UCSC.hg19.knownGene")
% library("TxDb.Hsapiens.UCSC.hg19.knownGene")
% genes_hg19 <- genes(TxDb.Hsapiens.UCSC.hg19.knownGene)
% genes_hg19
% @
% 
% Get transcriptional strand information for all SBS and DBS positions in the
% first VCF object with \Rfunction{mut\_strand}. This function returns ``-'' for
% positions outside gene bodies, and positions that overlap with more than one
% gene on different strands.
% 
% <<mut_strand>>=
% strand = mut_strand(vcfs[[1]], genes_hg19, type = c("snv", "dbs"))
% lapply(strand, head, 10)
% @
% 
% Make mutation count matrix with transcriptional strand information (96
% trinucleotides * 2 strands = 192 features for SBS and 78 substitutions * 2
% strands = 156 features for DBS). NB: only those mutations that are
% located within gene bodies are counted.
% 
% <<mut_matrix_stranded>>=
% mut_mat_s <- mut_matrix_stranded(vcfs, ref_genome, genes_hg19,
%                                  type = c("snv", "dbs"))
% lapply(mut_mat_s, function(x) x[1:5,1:5])
% @
% 
% Count the number of mutations on each strand, per tissue, per mutation type:
% 
% <<strand_occurrences>>=
% strand_counts <- strand_occurrences(mut_mat_s, by=tissue,
%                                     type = c("snv", "dbs"))
% lapply(strand_counts, head)
% @
% 
% Perform Poisson test for strand asymmetry significance testing:
% 
% <<strand_bias_test>>=
% strand_bias <- strand_bias_test(strand_counts,
%                                 type = c("snv", "dbs"))
% strand_bias
% @
% 
% Plot the mutation spectrum with strand distinction:
% <<plot_strand>>=
% ps1 <- plot_strand(strand_counts, mode = "relative")
% @
% 
% Plot the effect size (log2(untranscribed/transcribed) of the strand bias.
% Asteriks indicate significant strand bias.
% <<plot_strand_bias_3>>=
% ps2 <- plot_strand_bias(strand_bias)
% @
% 
% Combine the plots into one figure:
% <<plot_strand_bias_e, eval=FALSE>>=
% grid.arrange(ps1, ps2)
% @
% 
% \begin{figure}[H]
% \begin{center}
% <<plot_strand_bias, fig=TRUE, width=7.5, height=5.5, echo=FALSE>>=
% grid.arrange(ps1, ps2)
% @
% \end{center}
% \end{figure}
% 
% 
% \subsection{Replicative strand bias analysis}
% 
% The involvement of replication-associated mechanisms can be evaluated by
% testing for a mutational bias between the leading and lagging strand. The
% replication strand is dependent on the locations of replication origins from
% which DNA replication is fired. However, replication timing is dynamic and
% cell-type specific, which makes replication strand determination less
% straightforward than transcriptional strand bias analysis. Replication timing
% profiles can be generated with Repli-Seq experiments. Once the replication
% direction is defined, a strand asymmetry analysis can be performed similarly as
% the transcription strand bias analysis.
% 
% Read example bed file provided with the package with replication direction
% annotation:
% 
% <<repli_file>>=
% repli_file = system.file("extdata/ReplicationDirectionRegionsHaradhvala.bed",
%                            package = "MutationalPatterns")
% repli_strand = read.table(repli_file, header = TRUE)
% # Store in GRanges object
% repli_strand_granges = GRanges(seqnames = repli_strand$Chr,
%   ranges = IRanges(start = repli_strand$Start + 1,
%                    end = repli_strand$Stop),
%   strand_info = repli_strand$Class)
% # UCSC seqlevelsstyle
% seqlevelsStyle(repli_strand_granges) = "UCSC"
% repli_strand_granges
% @
% 
% The GRanges object should have a ``strand\_info'' metadata column, which
% contains only two different annotations, e.g. ``left'' and ``right'', or
% ``leading'' and ``lagging''. The genomic ranges cannot overlap, to allow only
% one annotation per location.
% 
% Get replicative strand information for all positions in the first VCF
% object. No strand information ``-'' is returned for base substitutions in
% unannotated genomic regions. Indels can also be tested for replication
% strand bias, since the strand information is not based on conversion of
% mutations.
% 
% <<strand_from_vcf_rep>>=
% strand_rep <- mut_strand(vcfs[[1]], repli_strand_granges, mode = "replication",
%                          type = "all")
% lapply(strand_rep, head, 10)
% @
% 
% Make mutation count matrices with transcriptional strand information.
% 
% <<mut_matrix_stranded_rep>>=
% mut_mat_s_rep <- mut_matrix_stranded(vcfs, ref_genome, repli_strand_granges,
%                                      mode = "replication",
%                                      type = "all")
% lapply(mut_mat_s_rep, function(x) x[1:5, 1:5])
% @
% 
% The levels of the "strand\_info" metadata in the GRanges object determines the
% order in which the strands are reported in the mutation matrix that is returned
% by \Rfunction{mut\_matrix\_stranded}, so if you want to count right before left,
% you can specify this, before you run \Rfunction{mut\_matrix\_stranded}:
% 
% <<specify_levels>>=
% repli_strand_granges$strand_info <- factor(repli_strand_granges$strand_info,
%                                            levels = c("right", "left"))
% mut_mat_s_rep2 <- mut_matrix_stranded(vcfs, ref_genome, repli_strand_granges,
%                                       mode = "replication",
%                                       type = "all")
% lapply(mut_mat_s_rep2, function(x) x[1:5, 1:5])
% @
% 
% Count the number of mutations on each strand, per tissue, per mutation type:
% 
% <<strand_occurrences_rep>>=
% strand_counts_rep <- strand_occurrences(mut_mat_s_rep, by=tissue,
%                                         type = "all")
% lapply(strand_counts_rep, head)
% @
% 
% Perform Poisson test for strand asymmetry significance testing:
% 
% <<strand_bias_test_rep>>=
% strand_bias_rep <- strand_bias_test(strand_counts_rep,
%                                     type = "all")
% strand_bias_rep
% @
% 
% Plot the mutation spectrum with strand distinction:
% 
% <<plot_strand_rep>>=
% ps1 <- plot_strand(strand_counts_rep, mode = "relative")
% @
% 
% Plot the effect size (log2(untranscribed/transcribed) of the strand bias.
% Asteriks indicate significant strand bias.
% 
% <<plot_strand_bias_rep2>>=
% ps2 <- plot_strand_bias(strand_bias_rep)
% @
% 
% Combine the plots into one figure:
% <<plot_strand_bias_rep_e, eval=FALSE>>=
% grid.arrange(ps1, ps2)
% @
% 
% \begin{figure}[H]
% \begin{center}
% <<plot_strand_bias_rep, fig=TRUE, width=7.5, height=5.5, echo=FALSE>>=
% grid.arrange(ps1, ps2)
% @
% \end{center}
% \end{figure}
% 
% \subsection{Extract signatures with strand bias}
% 
% Extract 2 signatures for each mutation type from mutation count matrix with
% strand features:
% 
% <<extract_signatures>>=
% nmf_res_strand <- extract_signatures(mut_mat_s_rep, type = "all", rank = 2, nrun = 1)
% 
% # Provide signature names
% colnames(nmf_res_strand$signatures$snv) <- c("SBS A", "SBS B")
% colnames(nmf_res_strand$signatures$dbs) <- c("DBS A", "DBS B")
% colnames(nmf_res_strand$signatures$indel) <- c("INDEL A", "INDEL B")
% @
% 
% Plot signatures with 192 features:
% 
% <<plot_192>>=
% a <- plot_strand_profiles(nmf_res_strand$signatures, condensed = TRUE,
%                           mode = "replication",
%                           type = "all")
% @
% 
% Plot strand bias per mutation type for each signature with significance test:
% <<plot_strand_bias>>=
% b <- plot_signature_strand_bias(nmf_res_strand$signatures,
%                                 type = "all")
% @
% 
% Combine the plots into one figure:
% <<plot_192_profile_noeval, eval=FALSE>>=
% grid.arrange(a, b, ncol = 2, widths = c(5, 1.8))
% @
% 
% \begin{figure}[H]
% \begin{center}
% <<plot_strand_bias_rep, fig=TRUE, width=7.5, height=5.5, echo=FALSE>>=
% grid.arrange(a, b, ncol = 2, widths = c(5, 1.8))
% @
% \end{center}
% \end{figure}
% 
% 
% \section{Genomic distribution}
% 
% \subsection{Rainfall plot}
% 
% A rainfall plot visualizes mutation types and intermutation distance. Rainfall
% plots can be used to visualize the distribution of mutations along the genome
% or a subset of chromosomes. The y-axis corresponds to the distance of a
% mutation with the previous mutation and is log10 transformed. Drop-downs from
% the plots indicate clusters or ``hotspots'' of mutations.
% 
% Make rainfall plot of single base substitutions from sample 1 over all
% autosomal chromosomes
% 
% <<plot_rainfall_noeval, eval=FALSE>>=
% # Define autosomal chromosomes
% chromosomes <- seqnames(get(ref_genome))[1:22]
% 
% # Make a rainfall plot
% plot_rainfall(vcfs[[1]], title = names(vcfs[1]),
%                 chromosomes = chromosomes, cex = 1.5, ylim = 1e+09)
% @
% 
% <<plot_rainfall, echo=FALSE>>=
% # Define autosomal chromosomes
% chromosomes <- seqnames(get(ref_genome))[1:22]
% 
% # Make a rainfall plot
% ggsave("plot_rainfall.pdf",
%        plot_rainfall(vcfs[[1]], title = names(vcfs[1]),
%                      chromosomes = chromosomes, cex = 1.5, ylim = 1e+09),
%        width=9,
%        height=3)
% @
% 
% \begin{figure}[H]
% \begin{center}
% \includegraphics[width=1.0\textwidth]{plot_rainfall}
% \end{center}
% \end{figure}
% 
% Also make rainfall plots for DBS and indels:
% 
% <<plot_rainfall_nosbs_noeval, eval = FALSE>>=
% # Define autosomal chromosomes
% chromosomes <- seqnames(get(ref_genome))[1:22]
% 
% # Make a rainfall plot
% plot_rainfall(vcfs[[1]], title = names(vcfs[1]),
%               chromosomes = chromosomes,
%               type = c("dbs", "indel"),
%               cex = 1.5, ylim = 1e+09)
% @
% 
% <<plot_rainfall, echo=FALSE>>=
% # Define autosomal chromosomes
% chromosomes <- seqnames(get(ref_genome))[1:22]
% 
% # Make a rainfall plot
% ggsave("plot_rainfall_dbs_indel.pdf",
%        plot_rainfall(vcfs[[1]], title = names(vcfs[1]),
%                      type = c("dbs", "indel"),
%                      chromosomes = chromosomes, cex = 1.5, ylim = 1e+09),
%        width=9,
%        height=3)
% @
% 
% \begin{figure}[H]
% \begin{center}
% \includegraphics[width=1.0\textwidth]{plot_rainfall_dbs_indel}
% \end{center}
% \end{figure}
% 
% % Make rainfall plot of the first sample over chromosome 1:
% %
% % \begin{figure}[H]
% % \begin{center}
% % <<plot_rainfall_2, fig=TRUE, width=6, height=3>>=
% % chromosomes <- seqnames(get(ref_genome))[1]
% % plot_rainfall(vcfs[[1]], title = names(vcfs[1]),
% %                 chromosomes = chromosomes[1], cex = 2, ylim = 1e+09)
% % @
% % \end{center}
% % \end{figure}
% 
% \subsection{Enrichment or depletion of mutations in genomic regions}
% 
% Test for enrichment or depletion of mutations in certain genomic regions, such
% as promoters, CTCF binding sites and transcription factor binding sites.  To
% use your own genomic region definitions (based on e.g. ChipSeq experiments)
% specify your genomic regions in a named list of GRanges objects.  Alternatively,
% use publicly available genomic annotation data, like in the example below.
% 
% \subsubsection{Example: regulation annotation data from Ensembl using
%     \Biocpkg{biomaRt}}
% 
% The following example displays how to download promoter, CTCF binding sites and
% transcription factor binding sites regions for
% genome build hg19 from Ensembl using \Biocpkg{biomaRt}.  For other datasets,
% see the  \Biocpkg{biomaRt} documentation \citep{Durinck2005}.
% 
% To install \Biocpkg{biomaRt}, uncomment the following lines:
% <<install_biomaRt, eval=FALSE>>=
% source("https://bioconductor.org/biocLite.R")
% biocLite("biomaRt")
% @
% 
% Load the \Biocpkg{biomaRt} package.
% <<load_biomart>>=
% library(biomaRt)
% @
% 
% Download genomic regions. NB: Here we take some shortcuts by loading the results
% from our example data. The corresponding code for downloading this data can be
% found above the command we run:
% 
% <<download_using_biomaRt>>=
% # regulatory <- useEnsembl(biomart="regulation",
% #                          dataset="hsapiens_regulatory_feature",
% #                          GRCh = 37)
% 
% ## Download the regulatory CTCF binding sites and convert them to
% ## a GRanges object.
% # CTCF <- getBM(attributes = c('chromosome_name',
% #                             'chromosome_start',
% #                             'chromosome_end',
% #                             'feature_type_name',
% #                             'cell_type_name'),
% #              filters = "regulatory_feature_type_name",
% #              values = "CTCF Binding Site",
% #              mart = regulatory)
% #
% # CTCF_g <- reduce(GRanges(CTCF$chromosome_name,
% #                 IRanges(CTCF$chromosome_start,
% #                 CTCF$chromosome_end)))
% 
% CTCF_g <- readRDS(system.file("states/CTCF_g_data.rds",
%                     package="MutationalPatterns"))
% 
% ## Download the promoter regions and convert them to a GRanges object.
% 
% # promoter = getBM(attributes = c('chromosome_name', 'chromosome_start',
% #                                 'chromosome_end', 'feature_type_name'),
% #                  filters = "regulatory_feature_type_name",
% #                  values = "Promoter",
% #                  mart = regulatory)
% # promoter_g = reduce(GRanges(promoter$chromosome_name,
% #                     IRanges(promoter$chromosome_start,
% #                             promoter$chromosome_end)))
% 
% promoter_g <- readRDS(system.file("states/promoter_g_data.rds",
%                         package="MutationalPatterns"))
% 
% ## Download the promoter flanking regions and convert them to a GRanges object.
% 
% # flanking = getBM(attributes = c('chromosome_name',
% #                                 'chromosome_start',
% #                                 'chromosome_end',
% #                                 'feature_type_name'),
% #                  filters = "regulatory_feature_type_name",
% #                  values = "Promoter Flanking Region",
% #                  mart = regulatory)
% # flanking_g = reduce(GRanges(
% #                        flanking$chromosome_name,
% #                        IRanges(flanking$chromosome_start,
% #                        flanking$chromosome_end)))
% 
% flanking_g <- readRDS(system.file("states/promoter_flanking_g_data.rds",
%                                     package="MutationalPatterns"))
% @
% 
% Combine all genomic regions (GRanges objects) in a named list:
% 
% <<combine_genomic_regions>>=
% regions <- GRangesList(promoter_g, flanking_g, CTCF_g)
% 
% names(regions) <- c("Promoter", "Promoter flanking", "CTCF")
% @
% 
% Use the same chromosome naming convention consistently:
% 
% <<combine_genomic_regions_2>>=
% seqlevelsStyle(regions) <- "UCSC"
% @
% 
% \subsection{Test for significant depletion or enrichment in genomic regions}
% 
% It is necessary to include a list with Granges of regions that were surveyed
% in your analysis for each sample, that is: positions in the genome at which
% you have enough high quality reads to call a mutation. This can
% be determined using e.g. CallableLoci tool by GATK. If you would not include the
% surveyed area in your analysis, you might for example see a depletion of
% mutations in a certain genomic region that is solely a result from a low
% coverage in that region, and therefore does not represent an actual depletion
% of mutations.
% 
% We provided an example surveyed region data file with the package. For simplicity,
% here we use the same surveyed file for each sample. For a proper analysis, determine
% the surveyed area per sample and use these in your analysis.
% 
% Download the example surveyed region data:
% 
% <<download_bed_data>>=
% ## Get the filename with surveyed/callable regions
% surveyed_file <- system.file("extdata/callableloci-sample.bed",
%                              package = "MutationalPatterns")
% 
% ## Import the file using rtracklayer and use the UCSC naming standard
% library(rtracklayer)
% surveyed <- import(surveyed_file)
% seqlevelsStyle(surveyed) <- "UCSC"
% 
% ## For this example we use the same surveyed file for each sample.
% surveyed_list <- rep(list(surveyed), 9)
% @
% 
% Test for enrichment or depletion of mutations in your defined genomic
% regions using a binomial test.  For this test, the chance of observing a
% mutation is calculated as the total number of mutations, divided by the
% total number of surveyed bases.
% 
% <<genomic_distribution>>=
% ## Calculate the number of observed and expected number of mutations in
% ## each genomic regions for each sample.
% distr <- genomic_distribution(vcfs, surveyed_list, regions, type = "all")
% @
% 
% <<enrichment_depletion_test>>=
% ## Perform the enrichment/depletion test by tissue type.
% distr_test <- enrichment_depletion_test(distr, by = tissue)
% head(distr_test)
% @
% 
% <<plot_enrichment_depletion_e, eval=FALSE>>=
% plot_enrichment_depletion(distr_test)
% @
% 
% \begin{figure}[H]
% \begin{center}
% <<plot_enrichment_depletion, fig=TRUE, width=7, height=5, echo=FALSE>>=
% plot_enrichment_depletion(distr_test)
% @
% \end{center}
% \end{figure}
% 
% \bibliography{references}
% 
% \section{Session Information}
% <<sessionInfo, eval=TRUE, echo=FALSE, results=tex>>=
% toLatex(sessionInfo())
% @

\end{document}
