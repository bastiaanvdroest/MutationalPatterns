%\VignetteIndexEntry{Introduction to MutationalPatterns}
\documentclass{article}
\usepackage{float}
\usepackage[natbibapa]{apacite}
\bibliographystyle{apacite}

<<style, eval=TRUE, echo=FALSE, results=tex>>=
BiocStyle::latex(use.unsrturl=FALSE)
@

\title{Introduction to \Biocpkg{MutationalPatterns}}
\author{Francis Blokzijl}
\author{Roel Janssen}
\author{Bastiaan Van der Roest}
\author{Ruben van Boxtel}
\author{Edwin Cuppen}
\affil{University Medical Center Utrecht, Utrecht, The Netherlands}
\date{\today}

\begin{document} 
\SweaveOpts{concordance=TRUE}

\maketitle

\tableofcontents

\newpage{}

<<options, echo=FALSE>>=
options(width=96)
library(ggplot2)
@

\section{Introduction}

Mutational processes leave characteristic footprints in genomic DNA. This
package provides a comprehensive set of flexible functions that allows
researchers to easily evaluate and visualize a multitude of mutational patterns
in base substitution catalogues of e.g. tumour samples or DNA-repair deficient
cells. The package covers a wide range of patterns including: mutational
signatures, transcriptional and replicative strand bias, genomic distribution
and association with genomic features, which are collectively meaningful for
studying the activity of mutational processes. The package provides
functionalities for both extracting mutational signatures \emph{de novo} and
determining the contribution of previously identified mutational signatures on
a single sample level. MutationalPatterns integrates with common R genomic
analysis workflows and allows easy association with (publicly available)
annotation data.

Background on the biological relevance of the different mutational patterns, a
practical illustration of the package functionalities, comparison with similar
tools and software packages and an elaborate discussion, are described in the
MutationalPatterns article, which is published in Genome Medicine in 2018:
  \url{https://doi.org/10.1186/s13073-018-0539-0}

\newpage{}
\section{Data}

To perform the mutational pattern analyses, you need to load one or multiple
VCF files with substitutions and/or indel calls and the corresponding reference
genome.

\subsection{List reference genome}

List available genomes using \Biocpkg{BSgenome}:
  
<<loading_reference_data>>=
library(BSgenome)
head(available.genomes())
@
  
Download and load your reference genome of interest:
  
<<loading_reference_data>>=
ref_genome <- "BSgenome.Hsapiens.UCSC.hg19"
library(ref_genome, character.only = TRUE)
@
  
\subsection{Load example data}

We provided an example data set with this package, which consists of a subset of
somatic mutation catalogues of 9 normal human adult stem cells from 3 different
tissues \citep{Blokzijl2016}.

Load the MutationalPatterns package:
  
<<load_package_e, eval = FALSE>>=
library(MutationalPatterns)
@

<<load_package, echo = FALSE>>=
devtools::load_all("../R")
@

Locate the VCF files of the example data:
<<locate_files_e, eval = FALSE>>=
vcf_files <- list.files(system.file("extdata", package="MutationalPatterns"),
                        pattern = ".vcf", full.names = TRUE)
@ 

<<locate_files, echo = FALSE>>=
vcf_files <- c("../../../HMF_data/DR010-update/data/160704_HMFregCPCT_FR10301986_FR12244591_CPCT02020306/CPCT02020306R_CPCT02020306T_post_processed_v2.2.vcf.gz",
              "../../../HMF_data/DR010-update/data/160704_HMFregCPCT_FR12244543_FR12244602_CPCT02030245/CPCT02030245R_CPCT02030245T_post_processed_v2.2.vcf.gz",
              "../../../HMF_data/DR010-update/data/160704_HMFregCPCT_FR12244545_FR12244599_CPCT02100011/CPCT02100011R_CPCT02100011T_post_processed_v2.2.vcf.gz",
              "../../../HMF_data/DR010-update/data/160704_HMFregCPCT_FR12244557_FR12244595_CPCT02110002/CPCT02110002R_CPCT02110002T_post_processed_v2.2.vcf.gz",
              "../../../HMF_data/DR010-update/data/160704_HMFregCPCT_FR12244561_FR12244603_CPCT02030247/CPCT02030247R_CPCT02030247T_post_processed_v2.2.vcf.gz",
              "../../../HMF_data/DR010-update/data/160709_HMFregCPCT_FR10301841_FR12244644_CPCT02020314/CPCT02020314R_CPCT02020314T_post_processed_v2.2.vcf.gz",
              "../../../HMF_data/DR010-update/data/160709_HMFregCPCT_FR10301926_FR10301880_CPCT02020307/CPCT02020307R_CPCT02020307T_post_processed_v2.2.vcf.gz",
              "../../../HMF_data/DR010-update/data/160709_HMFregCPCT_FR10301967_FR10301879_CPCT02020310/CPCT02020310R_CPCT02020310T_post_processed_v2.2.vcf.gz",
              "../../../HMF_data/DR010-update/data/160709_HMFregCPCT_FR10301974_FR10301881_CPCT02020308/CPCT02020308R_CPCT02020308T_post_processed_v2.2.vcf.gz")
@

Define corresponding sample names for the VCF files:
<<set_sample_names>>=
sample_names <- c(
  "colon1", "colon2", "colon3",
  "intestine1", "intestine2", "intestine3",
  "liver1", "liver2", "liver3")
@

Load the VCF files into a \texttt{GRangesList}:
<<read_vcfs_as_granges>>=
vcfs <- read_vcfs_as_granges(vcf_files, sample_names, ref_genome)
summary(vcfs)
@
  
Define relevant metadata on the samples, such as tissue type:
<<store_tissue_variable>>=
tissue <- c(rep("colon", 3), rep("intestine", 3), rep("liver", 3))
@
  
  
\section{Mutation characteristics}

\subsection{Single base substitution types}

We can retrieve base substitutions from the VCF GRanges object as "REF>ALT"
using \Rfunction{mutations\_from\_vcf}:
  
<<mutations_from_vcf>>=
muts = mutations_from_vcf(vcfs[[1]])
head(muts, 12)
@
  
We can retrieve the base substitutions from the VCF GRanges object and convert
them to the 6 types of base substitution types that are distinguished by
convention: C>A, C>G, C>T, T>A, T>C, T>G. For example, when the reference
allele is G and the alternative allele is T (G>T), \Rfunction{mut\_type}
returns the G:C>T:A mutation as a C>A mutation:
  
<<mut_type>>=
types = mut_type(vcfs[[1]])
head(types, 12)
@
  
To retrieve the sequence context (one base upstream and one base downstream) of
the single base substitutions in the VCF object from the reference genome, you can use
the \Rfunction{mut\_context} function:
  
<<mut_context>>=
context = mut_context(vcfs[[1]], ref_genome)
head(context, 12)
@
  
With \Rfunction{type\_context}, you can retrieve the types and contexts
for all positions in the VCF GRanges object. For the base substitutions that are
converted to the conventional base substitution types, the reverse complement of
the sequence context is returned.

<<type_context>>=
type_context = type_context(vcfs[[1]], ref_genome)
lapply(type_context, head, 12)
@
  
With \Rfunction{mut\_type\_occurrences}, you can count mutation type
occurrences for all VCF objects in the \texttt{GRangesList}. For
C>T mutations, a distinction is made between C>T at CpG sites and other
sites, as deamination of methylated cytosine at CpG sites is a common mutational
process. For this reason, the reference genome is needed for this functionality.

<<mut_type_occurrences>>=
type_occurrences <- mut_type_occurrences(vcfs, ref_genome)
type_occurrences
@

\subsection{Double base substitutions and indels}

Not only single base substitutions can be retrieved from the VCF GRanges object,
but there is also the option to extract double base substitutions and/or indels,
if they are present in the loaded VCF files. When multiple mutation types are
requested, the output will be a list of mutation types.\\

These two types of mutations are retrieved the same way as the single base 
substitutions: "REF>ALT", using \Rfunction{mutations\_from\_vcf}.
Therefore set the argument \texttt{type} to a vector of the wanted mutation
types:
  
<<mutations_from_vcf>>=
muts = mutations_from_vcf(vcfs[[1]], type = c("dbs", "indel"))
lapply(muts, head, 12)
@

To convert the double base substitutions to the 78 strand-agnostic types found
in the COSMIC database, run the function \Rfunction{mut\_type}. The 1 basepair
indels will also be converted to a "C" or "T" indel with this function:

<<mut_type>>=
types = mut_type(vcfs[[1]], type = c("dbs", "indel"))
lapply(types, head, 12)
@

The insertions and deletions can be translated a more clear definition, on
which the indels can be grouped. Since there is no single intuitive and 
naturally constrained set of indel mutation types, it is possible to give
an own definition of indels and to set global variables for this definition.
For this the function \Rfunction{indel\_mutation\_type} can be used. To set 
the indel context following the COSMIC database, use:

<<indel_mut_type>>=
indel_mutation_type("cosmic")
@

Then the indel mutations can be translated with \Rfunction{mut\_context}:

<<mut_context>>=
context = mut_context(vcfs[[1]], ref_genome, type = "indel", indel = "cosmic")
head(context, 12)
@

As with the single base substitutions, \Rfunction{type\_context} can be used
to retrieve type and context information of all double base substitutions, 
insertions and deletions. The function will return the type and context 
information as a list of mutation types:

<<type_context>>=
type_context = type_context(vcfs[[1]], ref_genome, type = c("dbs","indel"))
lapply(type_context, function(x) lapply(x, head, 12))
@

\subsection{Mutation spectrum}

A mutation spectrum shows the relative contribution of each mutation type in
the base substitution catalogs. The \Rfunction{plot\_spectrum} function plots
the mean relative contribution of each of the 6 base substitution types over
all samples. Error bars indicate standard deviation over all samples. The total
number of mutations is indicated.

<<plot_spectrum>>=
p1 <- plot_spectrum(type_occurrences)
@
  
Plot the mutation spectrum with distinction
between C>T at CpG sites and other sites:
  
<<plot_spectrum_2>>=
p2 <- plot_spectrum(type_occurrences, CT = TRUE)
@
  
Plot spectrum without legend:
<<plot_spectrum_3>>=
p3 <- plot_spectrum(type_occurrences, CT = TRUE, legend = FALSE)
@
  
The gridExtra package will be used throughout this vignette to combine multiple
plots:
<<combine_plot_spectrum_noeval, eval=FALSE>>=
library("gridExtra")
grid.arrange(p1, p2, p3, ncol=3, widths=c(3,3,1.75))
@
<<combine_plot_spectrum, echo=FALSE>>=
library("gridExtra")
ggsave("combine_plot_spectrum.pdf",
  grid.arrange(p1, p2, p3, ncol=3, widths=c(3,3,1.75)),
  width=10,
  height=3)
@
  
\begin{figure}[H]
\begin{center}
\includegraphics[width=1.0\textwidth]{combine_plot_spectrum}
\end{center}
\end{figure}

You can facet the per sample group, e.g. plot the spectrum for each tissue
separately:
<<plot_spectrum_4>>=
p4 <- plot_spectrum(type_occurrences, by = tissue, CT = TRUE, legend = TRUE)
@
  
Define your own 7 colors for spectrum plotting:
<<plot_spectrum_5>>=
palette <- c("pink", "orange", "blue", "lightblue", "green", "red", "purple")
p5 <- plot_spectrum(type_occurrences, CT=TRUE, legend=TRUE, colors=palette)
@
  
<<combine_plot_spectrum_2_noeval, echo=FALSE>>=
ggsave("combine_plot_spectrum_2.pdf", 
       grid.arrange(p4, p5, ncol=2, widths=c(4,2.3)), 
       width=10, 
       height=3)
@
  
<<combine_plot_spectrum_2, eval=FALSE>>=
grid.arrange(p4, p5, ncol=2, widths=c(4,2.3))
@
  
\begin{figure}[H]
\begin{center}
\includegraphics[width=1.0\textwidth]{combine_plot_spectrum_2}
\end{center}
\end{figure}

\subsection{96 mutational profile}

Make a 96 trinucleodide mutation count matrix:
<<mut_matrix>>=
mut_mat <- mut_matrix(vcf_list = vcfs, ref_genome = ref_genome)
head(mut_mat)
@
  
Plot the 96 profile of two samples:
<<plot_96_profile_2_e, eval=FALSE, width=7, height=3>>=
plot_profiles(mut_mat[,c(1,7)])
@
  
\begin{figure}[H]
\begin{center}
<<plot_96_profile_2, fig=TRUE, width=7, height=3, echo=FALSE>>=
plot_profiles(mut_mat[,c(1,7)])
@
\end{center}
\end{figure}

Plot 96 profile of two samples in a more condensed plotting format:
<<plot_96_profile_3_e, eval=FALSE, width=7, height=3>>=
plot_profiles(mut_mat[,c(1,7)], condensed = TRUE)
@
  
\begin{figure}[H]
\begin{center}
<<plot_96_profile_3, fig=TRUE, width=7, height=3, echo=FALSE>>=
plot_profiles(mut_mat[,c(1,7)], condensed = TRUE)
@
\end{center}
\end{figure}

\subsection{Plot mutation profiles of different types}

To plot the mutation profiles of different mutation types (SBS, DBS 
and/or indels), first make a list of mutation count matrices:

<<mut_matrix>>=
mut_mat <- mut_matrix(vcf_list = vcfs, ref_genome = ref_genome, type = "all")
lapply(mut_mat, head)
@

Make a list of two samples:
<<sub_mat_matrix>>=
mut_mat_sub <- list("snv" = mut_mat$snv[,c(1,7)],
                    "dbs" = mut_mat$dbs[,c(1,7)],
                    "indel" = mut_mat$indel[,c(1,7)])
@

Plot the mutation profiles of the two samples:
<<plot_profiles_2e, eval=FALSE, width=7, height=3>>=
plot_profiles(mut_mat_sub, type = "all")
@

\begin{figure}[H]
\begin{center}
<<plot_profiles_2, fig=TRUE, width=7, height=3, echo=FALSE>>=
plot_profiles(mut_mat_sub, type = "all")
@
\end{center}
\end{figure}

It is also possible to plot mutation profiles with all mutation types
together. 

<<plot_profiles_3e, eval=FALSE, width=7, height=3>>=
plot_profiles(mut_mat_sub, type = "all", method = "combine")
@

\begin{figure}[H]
\begin{center}
<<plot_profiles_3, fig=TRUE, width=7, height=3, echo=FALSE>>=
plot_profiles(mut_mat_sub, type = "all", method = "combine")
@
\end{center}
\end{figure}

\newpage{}
\section{Mutational signatures}

\subsection{\textit{De novo} mutational signature extraction using NMF}

Mutational signatures are thought to represent mutational processes, and are
characterized by a specific contribution of 96 single base substitution types,
78 double bas substitutions types or indels. Mutational signatures can be 
extracted from your mutation count matrix, with non-negative matrix 
factorization (NMF). A critical parameter in NMF is the factorization rank,
which is the number of mutational signatures. You can determine the optimal 
factorization rank using the NMF package \citep{Gaujoux2010}. As described in 
their paper:

``...a common
way of deciding on the rank is to try different values, compute some quality
measure of the results, and choose the best value according to this quality
criteria. The most common approach is to choose the smallest rank for which
cophenetic correlation coefficient starts decreasing. Another approach is to
choose the rank for which the plot of the residual sum of squares (RSS) between
the input matrix and its estimate shows an inflection point.''

Lets start with the single base substitutions. First add a small psuedocount 
to your mutation count matrix, such that there are no rows where the sum of 
the row is zero:

<<psuedo_count>>=
mut_mat <- mut_matrix(vcf_list = vcfs, ref_genome = ref_genome)
mut_mat <- mut_mat + 0.0001
@

Use the NMF package to generate an estimate rank plot:
<<use_nmf>>=
library("NMF")
estimate <- nmf(mut_mat, rank=2:5, method="brunet", nrun=10, seed=123456)
@

And plot it:
<<estimate_rank_e, eval=FALSE, width=7, height=5>>=
plot(estimate)
@

\begin{figure}[H]
\begin{center}
<<estimate_rank, fig=TRUE, width=7, height=5, echo=FALSE>>=
plot(estimate)
@
\end{center}
\end{figure}

Extract 2 mutational signatures from the mutation count matrix with
\Rfunction{extract\_signatures} (For larger datasets it is wise to perform more
iterations by changing the nrun parameter to achieve stability and avoid local
minima):

<<extract_signatures>>=
nmf_res <- extract_signatures(mut_mat, rank = 2, nrun = 10)
@

Assign signature names:
<<add_column_names>>=
colnames(nmf_res$signatures) <- c("Signature A", "Signature B")
rownames(nmf_res$contribution) <- c("Signature A", "Signature B")
@

Plot the 96-profile of the signatures:
<<plot_profiles_e, eval=FALSE, width=7, height=3>>=
plot_profiles(nmf_res$signatures, condensed = TRUE)
@

\begin{figure}[H]
\begin{center}
<<plot_profiles, fig=TRUE, width=7, height=10, echo=FALSE>>=
plot_profiles(nmf_res$signatures, condensed = TRUE)
@
\end{center}
\end{figure}

In order to extract signatures for DBS and indels, make a list of mutation 
matrices for each mutation type:

<<mut_matrix_all_2>>=
mut_mat <- mut_matrix(vcf_list = vcfs, ref_genome = ref_genome, type = "all")
mut_mat <- lapply(mut_mat, function(x) x + 0.0001)
@

Generate a estimate rank plot with the NMF package for each mutation type and
find the best ranks. Extract then the signatures from the mutation matrices 
with \Rfunction{extract\_signatures}.

<<extract_signatures_all>>=
nmf_res <- extract_signatures(mut_mat, 
                              rank = c("snv" = 2, "dbs" = 2, "indel" = 2), 
                              type = "all",
                              nrun = 10)
@

Assign signature names
<<add_column_names>>=
colnames(nmf_res$signatures$snv) <- c("SBS A", "SBS B")
colnames(nmf_res$signatures$dbs) <- c("DBS A", "DBS B")
colnames(nmf_res$signatures$indel) <- c("INDEL A", "INDEL B")
rownames(nmf_res$contribution$snv) <- c("SBS A", "SBS B")
rownames(nmf_res$contribution$dbs) <- c("DBS A", "DBS B")
rownames(nmf_res$contribution$indel) <- c("INDEL A", "INDEL B")
@

Plot the profiles of the signatures:
<<plot_profiles_e, eval=FALSE, width=7, height=3>>=
plot_profiles(nmf_res$signatures, condensed = TRUE, type = "all")
@

\begin{figure}[H]
\begin{center}
<<plot_profiles, fig=TRUE, width=7, height=10, echo=FALSE>>=
plot_profiles(nmf_res$signatures, condensed = TRUE, type = "all")
@
\end{center}
\end{figure}

Visualize the contribution of the SBS signatures in a barplot:
<<plot_contribution>>=
pc1 <- plot_contribution(nmf_res$contribution, nmf_res$signature,
                         mode = "relative")
@

Visualize the contribution of the signatures in absolute number of mutations:
<<plot_contribution_2>>=
pc2 <- plot_contribution(nmf_res$contribution, nmf_res$signature,
                         mode = "absolute")
@

Combine the two plots:
<<plot_contribution_2_fig_e, fig=TRUE, width=7, height=5, eval=FALSE>>=
grid.arrange(pc1, pc2)
@

\begin{figure}[H]
\begin{center}
<<plot_contribution_2_fig, fig=TRUE, width=7, height=5, echo=FALSE>>=
grid.arrange(pc1, pc2)
@
\end{center}
\end{figure}

Flip X and Y coordinates:

<<plot_contribution_4_e, eval=FALSE>>=
plot_contribution(nmf_res$contribution, nmf_res$signature,
                         mode = "absolute", coord_flip = TRUE)
@

\begin{figure}[H]
\begin{center}
<<plot_contribution_4, fig=TRUE, width=7, height=4, echo=FALSE>>=
plot_contribution(nmf_res$contribution, nmf_res$signature,
                         mode = "absolute", coord_flip = TRUE)
@
\end{center}
\end{figure}

Visualize the contribution of all signatures in both relative and
absolute number of mutations:

<<plot_contribution_all_e, fig=TRUE, width=7, height=5, eval=FALSE>>=
plot_contribution(nmf_res$contribution, nmf_res$signature,
                 type = "all", mode = "both")
@

\begin{figure}[H]
\begin{center}
<<plot_contribution_all, fig=TRUE, width=7, height=5, echo=FALSE>>=
plot_contribution(nmf_res$contribution, nmf_res$signature,
                       type = "all", mode = "both")
@
\end{center}
\end{figure}

The relative contribution of each signature for each sample can also be plotted
as a heatmap with \Rfunction{plot\_contribution\_heatmap}, which might be easier
to interpret and compare than stacked barplots. The samples can be
hierarchically clustered based on their euclidean distance. The signatures can
be plotted in a user-specified order.

Plot SBS signature contribution as a heatmap with sample clustering dendrogram and
a specified signature order:

<<plot_contribution_heatmap>>=
pch1 <- plot_contribution_heatmap(nmf_res$contribution,
                                  sig_order = c("SBS B", "SBS A"))
@

Plot SBS signature contribution as a heatmap without sample clustering:
<<plot_contribution_heatmap2_e>>=
pch2 <- plot_contribution_heatmap(nmf_res$contribution, cluster_samples=FALSE)
@

Combine the plots into one figure:
<<plot_contribution_heatmap2_e2, eval=FALSE>>=
grid.arrange(pch1, pch2, ncol = 2, widths = c(2,1.6))
@

\begin{figure}[H]
\begin{center}
<<plot_contribution_heatmap2, fig=TRUE, width=10, height=10, echo=FALSE>>=
grid.arrange(pch1, pch2, ncol = 2, widths = c(2,1.6))
@
\end{center}
\end{figure}

When plotting the signature contribution of multiple mutation types, it is
possible to cluster on a specified mutation type. The mutation type(s) on
which the data will be clustered, will show up at the left side of the heatmap.

<<plot_contribution_heatmap_all_e, eval=FALSE>>=
plot_contribution_heatmap(nmf_res$contribution, type = "all", 
                          cluster_mut_type = "dbs",
                          plot_values = TRUE)
@

\begin{figure}[H]
\begin{center}
<<plot_contribution_heatmap_all, fig=TRUE, width=10, height=10, echo=FALSE>>=
plot_contribution_heatmap(nmf_res$contribution, type = "all",
                          cluster_mut_type = "dbs",
                          plot_values = TRUE)
@
\end{center}
\end{figure}

Compare the reconstructed mutational profile with the original mutational
profile:

<<plot_compare_profiles_e, eval=FALSE>>=
plot_compare_profiles(mut_mat$snv[,1],
                        nmf_res$snv$reconstructed[,1],
                        profile_names = c("Original", "Reconstructed"),
                        condensed = TRUE)
@

\begin{figure}[H]
\begin{center}
<<plot_compare_profiles, fig=TRUE, width=6, height=5.5, echo=FALSE>>=
plot_compare_profiles(mut_mat$snv[,1],
                        nmf_res$reconstructed$snv[,1],
                        profile_names = c("Original", "Reconstructed"),
                        condensed = TRUE)
@
\end{center}
\end{figure}

\subsection{Find optimal contribution of known signatures}

\subsubsection{COSMIC mutational signatures}

Download mutational signatures from the COSMIC website. For convenience
the SBS signatures of version 2 are used:

<<download_cancer_signatures>>=
sp_url <- paste("https://cancer.sanger.ac.uk/cancergenome/assets/",
                "signatures_probabilities.txt", sep = "")

snv_signatures = read.table(sp_url, sep = "\t", header = TRUE)
# Match the order of the mutation types to MutationalPatterns standard
new_order = match(row.names(mut_mat$snv), snv_signatures$Somatic.Mutation.Type)
# Reorder cancer signatures dataframe
snv_signatures = snv_signatures[as.vector(new_order),]
# Add trinucletiode changes names as row.names
row.names(snv_signatures) = snv_signatures$Somatic.Mutation.Type
# Keep only 96 contributions of the signatures in matrix
snv_signatures = as.matrix(snv_signatures[,4:33])
@

DBS and indel signatures are available from synapse.org ID syn12009743.
Download the reference whole-genome signatures.

<<load_signatures_e, eval = FALSE>>=
dbs_signatures = read.csv("sigProfiler_DBS_signatures.csv")
rownames(dbs_signatures) = dbs_signatures$Mutation.Type
dbs_signatures = as.matrix(dbs_signatures[,2:11])

indel_signatures = read.csv("sigProfiler_ID_signatures.csv")
rownames(indel_signatures) = INDEL_COSMIC
indel_signatures = as.matrix(indel_signatures[,2:18])

cancer_signatures = list("snv" = snv_signatures,
                         "dbs" = dbs_signatures,
                         "indel" = indel_signatures)
@

<<load_signatures, echo = FALSE>>=
dbs_signatures = read.csv("../../sigProfiler_DBS_signatures.csv")
rownames(dbs_signatures) = dbs_signatures$Mutation.Type
dbs_signatures = as.matrix(dbs_signatures[,2:11])

indel_signatures = read.csv("../../sigProfiler_ID_signatures.csv")
rownames(indel_signatures) = INDEL_COSMIC
indel_signatures = as.matrix(indel_signatures[,2:18])

cancer_signatures = list("snv" = snv_signatures,
                         "dbs" = dbs_signatures,
                         "indel" = indel_signatures)
@

Plot mutational profile of the first two COSMIC SBS signatures:
<<plot_profiles_COSMIC_e, eval=FALSE>>=
plot_profiles(cancer_signatures$snv[,1:2], condensed = TRUE, ymax = 0.3)
@

\begin{figure}[H]
\begin{center}
<<plot_profiles_COSMIC, fig=TRUE, width=7, height=3, echo=FALSE>>=
plot_profiles(cancer_signatures$snv[,1:2], condensed = TRUE, ymax = 0.3)
@
\end{center}
\end{figure}

Hierarchically cluster the COSMIC SBS signatures based on their similarity with
average linkage:

<<cluster_COSMIC, fig=TRUE, width=7, height=5>>=
hclust_cosmic = cluster_signatures(cancer_signatures$snv, method = "average")
# store signatures in new order
cosmic_order = colnames(cancer_signatures$snv)[hclust_cosmic$order]
plot(hclust_cosmic)
@

\subsubsection{Similarity between mutational profiles and COSMIC signatures}

The similarity between each mutational profile and each COSMIC signature, can be
calculated with \Rfunction{cos\_sim\_matrix}, and visualized with
\Rfunction{plot\_cosine\_heatmap}. The cosine similarity reflects how well each
mutational profile can be explained by each signature individually. The
advantage of this heatmap representation is that it shows in a glance the
similarity in mutational profiles between samples, while at the same time
providing information on which signatures are most prominent. The samples can be
hierarchically clustered in \Rfunction{plot\_cosine\_heatmap}.

The cosine similarity between two mutational profiles/signatures can be
calculated with \Rfunction{cos\_sim}:

<<cos_sim>>=
cos_sim(mut_mat$snv[,1], cancer_signatures$snv[,1])
@

Calculate pairwise cosine similarity between mutational profiles of
single base substitutions and COSMIC signatures:

\begin{figure}[H]
\begin{center}
<<cos_sim_cosmic_samples, fig=TRUE, width=7, height=3.5>>=
cos_sim_samples_signatures = cos_sim_matrix(mut_mat, cancer_signatures,
                                            type = "all")
# Plot heatmap with specified signature order
plot_cosine_heatmap(cos_sim_samples_signatures$snv,
                    cluster_rows = TRUE)
@
\end{center}
\end{figure}

\subsubsection{Find optimal contribution of COSMIC signatures to reconstruct mutational profiles}

In addition to \textit{de novo} extraction of signatures, the contribution of
any set of signatures to the mutational profile of a sample can be quantified.
This unique feature is specifically useful for mutational signature analyses of
small cohorts or individual samples, but also to relate own findings to known
signatures and published findings. The  \Rfunction{fit\_to\_signatures} function
has two options to find the optimal linear combination of mutational signatures
that most closely reconstructs the mutation matrix: solving a non-negative
least-squares constraints problem and performing a golden ratio search (as
implemented in the deconstructSigs package from Rosenthal et al.
\citep{Rosenthal2016}). The default option is the non-negative least-squares
problem.

Fit mutation matrix to the COSMIC SBS mutational signatures:

<<fit_to_signatures>>=
fit_res <- fit_to_signatures(mut_mat, cancer_signatures)
@

Plot the optimal contribution of the COSMIC signatures in each sample as a
stacked barplot.

<<plot_contribution_3_noeval, eval=FALSE>>=
# Select signatures with some contribution
select <- which(rowSums(fit_res$contribution) > 10)
# Plot contribution barplot
plot_contribution(fit_res$contribution[select,],
                    cancer_signatures$snv[,select],
                    coord_flip = FALSE,
                    mode = "absolute")
@

\begin{figure}[H]
\begin{center}
<<plot_contribution_3, echo=FALSE>>=
# Select signatures with some contribution
select <- which(rowSums(fit_res$contribution) > 10)
# Plot contribution
plot_contribution(fit_res$contribution[select,],
                  cancer_signatures$snv[,select],
                  coord_flip = FALSE,
                  mode = "absolute")
@
\end{center}
\end{figure}

Results of the golden ratio search algorithm are only relative, so fit
the mutation matrix with the golden ratio search and plot results from
both methods in relative contribution:

<<fit_to_signatures_grs>>=
fit_res_grs <- fit_to_signatures(mut_mat, cancer_signatures,
                             method = "golden-ratio-search")
# Select signatures with some contribution
select_grs <- which(rowSums(fit_res_grs$contribution) > 0.06)

# Make a color vector for SBS signatures such that colors will match in
# results from both algorithms
colorvector <- default_colors_ggplot(ncol(cancer_signatures$snv))

# Plot relative contribution from non-negative least squares
pc1 <- plot_contribution(fit_res$contribution[select,],
                    cancer_signatures$snv[,select],
                    coord_flip = FALSE,
                    mode = "relative",
                    palette = list("snv" = colorvector[select]))

# Plot relative contribution from golden ratio search
pc2 <- plot_contribution(fit_res_grs$contribution[select_grs,],
                         cancer_signatures$snv[,select_grs],
                         coord_flip = FALSE,
                         mode = "relative",
                         palette = list("snv" = colorvector[select_grs]))
@

\begin{figure}[H]
\begin{center}
<<plot_contribution_heatmap2, fig=TRUE, width=6, height=3, echo=FALSE>>=
grid.arrange(pc1, pc2, ncol = 2, widths = c(2,2))
@
\end{center}
\end{figure}

Plot relative contribution fitted with the non-negative least-squares problem
of the SBS cancer signatures in each sample as a heatmap with sample
clustering:
<<plot_contribution_heatmap3_e, eval=FALSE>>=
plot_contribution_heatmap(fit_res$contribution,
                          cluster_samples = TRUE,
                          method = "complete")
@

\begin{figure}[H]
\begin{center}
<<plot_contribution_heatmap3, fig=TRUE, width=8, height=3, echo=FALSE>>=
plot_contribution_heatmap(fit_res$contribution,
                          cluster_samples = TRUE,
                          method = "complete")
@
\end{center}
\end{figure}

Compare the reconstructed mutational profile of sample 1
with its original mutational profile:
<<plot_compare_profiles_2_e, eval=FALSE>>=
plot_compare_profiles(mut_mat$snv[,1], fit_res$reconstructed[,1],
                        profile_names = c("Original", "Reconstructed"),
                        condensed = TRUE)
@

\begin{figure}[H]
\begin{center}
<<plot_compare_profiles_2, fig=TRUE, width=6, height=5.5, echo=FALSE>>=
plot_compare_profiles(mut_mat$snv[,1], fit_res$reconstructed[,1],
                        profile_names = c("Original", "Reconstructed"),
                        condensed = TRUE)
@
\end{center}
\end{figure}

Calculate the cosine similarity between all original and reconstructed
mutational profiles with \Rfunction{cos\_sim\_matrix}:

<<cos_sim_ori_rec>>=
# calculate all pairwise cosine similarities
cos_sim_ori_rec <- cos_sim_matrix(mut_mat$snv, fit_res$reconstructed)
# extract cosine similarities per sample between original and reconstructed
cos_sim_ori_rec <- as.data.frame(diag(cos_sim_ori_rec))
@

We can use ggplot to make a barplot of the cosine similarities between the
original and reconstructed mutational profile of each sample. This clearly
shows how well each mutational profile can be reconstructed with the COSMIC
mutational signatures. Two identical profiles have a cosine similarity of 1.
The lower the cosine similarity between original and reconstructed, the less
well the original mutational profile can be reconstructed with the COSMIC
signatures. You could use, for example, cosine similarity of 0.95 as a cutoff.

<<cos_sim_ori_rec>>=
# Adjust data frame for plotting with gpplot
colnames(cos_sim_ori_rec) = "cos_sim"
cos_sim_ori_rec$sample = row.names(cos_sim_ori_rec)
@

<<plot_cos_sim_ori_rec_e, eval=FALSE>>=
# Load ggplot2
library(ggplot2)
# Make barplot
ggplot(cos_sim_ori_rec, aes(y=cos_sim, x=sample)) +
  geom_bar(stat="identity", fill = "skyblue4") +
  coord_cartesian(ylim=c(0.8, 1)) +
  # coord_flip(ylim=c(0.8,1)) +
  ylab("Cosine similarity\n original VS reconstructed") +
  xlab("") +
  # Reverse order of the samples such that first is up
  # xlim(rev(levels(factor(cos_sim_ori_rec$sample)))) +
  theme_bw() +
  theme(panel.grid.minor.y=element_blank(),
        panel.grid.major.y=element_blank()) +
  # Add cut.off line
  geom_hline(aes(yintercept=.95))
@

\begin{figure}[H]
\begin{center}
<<plot_cos_sim_ori_rec, fig=TRUE, width=6, height=3, echo=FALSE>>=
# Load ggplot2
library(ggplot2)
# Make barplot
ggplot(cos_sim_ori_rec, aes(y=cos_sim, x=sample)) +
  geom_bar(stat="identity", fill = "skyblue4") +
  coord_cartesian(ylim=c(0.8, 1)) +
  # coord_flip(ylim=c(0.8,1)) +
  ylab("Cosine similarity\n original VS reconstructed") +
  xlab("") +
  # Reverse order of the samples such that first is up
  # xlim(rev(levels(factor(cos_sim_ori_rec$sample)))) +
  theme_bw() +
  theme(panel.grid.minor.y=element_blank(),
        panel.grid.major.y=element_blank()) +
  # Add cut.off line
  geom_hline(aes(yintercept=.95))
@
\end{center}
\end{figure}

\section{Strand bias analyses}

\subsection{Transcriptional strand bias analysis}

For the mutations within genes it can be determined whether the mutation is
on the transcribed or non-transcribed strand, which can be used to evaluate
the involvement of transcription-coupled repair. To this end, it is determined
whether the "C" or "T" base (since by convention we regard base substitutions
as C>X or T>X) are on the same strand as the gene definition. Single base
substitions on the same strand as the gene definitions are considered
"untranscribed", and on the opposite strand of gene bodies as "transcribed",
since the gene definitions report the coding or sense strand, which is
untranscribed. No strand information is reported for base substitution that
overlap with more than one gene body on different strands.

Alike the single base substitutions, double base substitutions are
converted to defined set of double bases. These bases are either on the same
strand as a gene definition, consider them "untranscribed", or on the other
strand, consider them "transcribed". Indels do not have such a conversion,
therefore losing strand information based on mutations.

Get gene definitions for your reference genome:

<<get_genes>>=
# For example get known genes table from UCSC for hg19 using
# biocLite("TxDb.Hsapiens.UCSC.hg19.knownGene")
library("TxDb.Hsapiens.UCSC.hg19.knownGene")
genes_hg19 <- genes(TxDb.Hsapiens.UCSC.hg19.knownGene)
genes_hg19
@

Get transcriptional strand information for all SBS and DBS positions in the
first VCF object with \Rfunction{mut\_strand}. This function returns ``-'' for
positions outside gene bodies, and positions that overlap with more than one
gene on different strands.

<<mut_strand>>=
strand = mut_strand(vcfs[[1]], genes_hg19, type = c("snv", "dbs"))
lapply(strand, head, 10)
@

Make mutation count matrix with transcriptional strand information (96
trinucleotides * 2 strands = 192 features for SBS and 78 substitutions * 2
strands = 156 features for DBS). NB: only those mutations that are
located within gene bodies are counted.

<<mut_matrix_stranded>>=
mut_mat_s <- mut_matrix_stranded(vcfs, ref_genome, genes_hg19,
                                 type = c("snv", "dbs"))
lapply(mut_mat_s, function(x) x[1:5,1:5])
@

Count the number of mutations on each strand, per tissue, per mutation type:

<<strand_occurrences>>=
strand_counts <- strand_occurrences(mut_mat_s, by=tissue,
                                    type = c("snv", "dbs"))
lapply(strand_counts, head)
@

Perform Poisson test for strand asymmetry significance testing:

<<strand_bias_test>>=
strand_bias <- strand_bias_test(strand_counts,
                                type = c("snv", "dbs"))
strand_bias
@

Plot the mutation spectrum with strand distinction:
<<plot_strand>>=
ps1 <- plot_strand(strand_counts, mode = "relative")
@

Plot the effect size (log2(untranscribed/transcribed) of the strand bias.
Asteriks indicate significant strand bias.
<<plot_strand_bias_3>>=
ps2 <- plot_strand_bias(strand_bias)
@

Combine the plots into one figure:
<<plot_strand_bias_e, eval=FALSE>>=
grid.arrange(ps1, ps2)
@

\begin{figure}[H]
\begin{center}
<<plot_strand_bias, fig=TRUE, width=7.5, height=5.5, echo=FALSE>>=
grid.arrange(ps1, ps2)
@
\end{center}
\end{figure}


\subsection{Replicative strand bias analysis}

The involvement of replication-associated mechanisms can be evaluated by
testing for a mutational bias between the leading and lagging strand. The
replication strand is dependent on the locations of replication origins from
which DNA replication is fired. However, replication timing is dynamic and
cell-type specific, which makes replication strand determination less
straightforward than transcriptional strand bias analysis. Replication timing
profiles can be generated with Repli-Seq experiments. Once the replication
direction is defined, a strand asymmetry analysis can be performed similarly as
the transcription strand bias analysis.

Read example bed file provided with the package with replication direction
annotation:

<<repli_file>>=
repli_file = system.file("extdata/ReplicationDirectionRegionsHaradhvala.bed",
                           package = "MutationalPatterns")
repli_strand = read.table(repli_file, header = TRUE)
# Store in GRanges object
repli_strand_granges = GRanges(seqnames = repli_strand$Chr,
  ranges = IRanges(start = repli_strand$Start + 1,
                   end = repli_strand$Stop),
  strand_info = repli_strand$Class)
# UCSC seqlevelsstyle
seqlevelsStyle(repli_strand_granges) = "UCSC"
repli_strand_granges
@

The GRanges object should have a ``strand\_info'' metadata column, which
contains only two different annotations, e.g. ``left'' and ``right'', or
``leading'' and ``lagging''. The genomic ranges cannot overlap, to allow only
one annotation per location.

Get replicative strand information for all positions in the first VCF
object. No strand information ``-'' is returned for base substitutions in
unannotated genomic regions. Indels can also be tested for replication
strand bias, since the strand information is not based on conversion of
mutations.

<<strand_from_vcf_rep>>=
strand_rep <- mut_strand(vcfs[[1]], repli_strand_granges, mode = "replication",
                         type = "all")
lapply(strand_rep, head, 10)
@

Make mutation count matrices with transcriptional strand information.

<<mut_matrix_stranded_rep>>=
mut_mat_s_rep <- mut_matrix_stranded(vcfs, ref_genome, repli_strand_granges,
                                     mode = "replication",
                                     type = "all")
lapply(mut_mat_s_rep, function(x) x[1:5, 1:5])
@

The levels of the "strand\_info" metadata in the GRanges object determines the
order in which the strands are reported in the mutation matrix that is returned
by \Rfunction{mut\_matrix\_stranded}, so if you want to count right before left,
you can specify this, before you run \Rfunction{mut\_matrix\_stranded}:

<<specify_levels>>=
repli_strand_granges$strand_info <- factor(repli_strand_granges$strand_info,
                                           levels = c("right", "left"))
mut_mat_s_rep2 <- mut_matrix_stranded(vcfs, ref_genome, repli_strand_granges,
                                      mode = "replication",
                                      type = "all")
lapply(mut_mat_s_rep2, function(x) x[1:5, 1:5])
@

Count the number of mutations on each strand, per tissue, per mutation type:

<<strand_occurrences_rep>>=
strand_counts_rep <- strand_occurrences(mut_mat_s_rep, by=tissue,
                                        type = "all")
lapply(strand_counts_rep, head)
@

Perform Poisson test for strand asymmetry significance testing:

<<strand_bias_test_rep>>=
strand_bias_rep <- strand_bias_test(strand_counts_rep,
                                    type = "all")
strand_bias_rep
@

Plot the mutation spectrum with strand distinction:

<<plot_strand_rep>>=
ps1 <- plot_strand(strand_counts_rep, mode = "relative")
@

Plot the effect size (log2(untranscribed/transcribed) of the strand bias.
Asteriks indicate significant strand bias.

<<plot_strand_bias_rep2>>=
ps2 <- plot_strand_bias(strand_bias_rep)
@

Combine the plots into one figure:
<<plot_strand_bias_rep_e, eval=FALSE>>=
grid.arrange(ps1, ps2)
@

\begin{figure}[H]
\begin{center}
<<plot_strand_bias_rep, fig=TRUE, width=7.5, height=5.5, echo=FALSE>>=
grid.arrange(ps1, ps2)
@
\end{center}
\end{figure}

\subsection{Extract signatures with strand bias}

Extract 2 signatures for each mutation type from mutation count matrix with
strand features:

<<extract_signatures>>=
nmf_res_strand <- extract_signatures(mut_mat_s_rep, type = "all", rank = 2, nrun = 1)

# Provide signature names
colnames(nmf_res_strand$signatures$snv) <- c("SBS A", "SBS B")
colnames(nmf_res_strand$signatures$dbs) <- c("DBS A", "DBS B")
colnames(nmf_res_strand$signatures$indel) <- c("INDEL A", "INDEL B")
@

Plot signatures with 192 features:

<<plot_192>>=
a <- plot_strand_profiles(nmf_res_strand$signatures, condensed = TRUE,
                          mode = "replication",
                          type = "all")
@

Plot strand bias per mutation type for each signature with significance test:
<<plot_strand_bias>>=
b <- plot_signature_strand_bias(nmf_res_strand$signatures,
                                type = "all")
@

Combine the plots into one figure:
<<plot_192_profile_noeval, eval=FALSE>>=
grid.arrange(a, b, ncol = 2, widths = c(5, 1.8))
@

\begin{figure}[H]
\begin{center}
<<plot_strand_bias_rep, fig=TRUE, width=7.5, height=5.5, echo=FALSE>>=
grid.arrange(a, b, ncol = 2, widths = c(5, 1.8))
@
\end{center}
\end{figure}


\section{Genomic distribution}

\subsection{Rainfall plot}

A rainfall plot visualizes mutation types and intermutation distance. Rainfall
plots can be used to visualize the distribution of mutations along the genome
or a subset of chromosomes. The y-axis corresponds to the distance of a
mutation with the previous mutation and is log10 transformed. Drop-downs from
the plots indicate clusters or ``hotspots'' of mutations.

Make rainfall plot of single base substitutions from sample 1 over all
autosomal chromosomes

<<plot_rainfall_noeval, eval=FALSE>>=
# Define autosomal chromosomes
chromosomes <- seqnames(get(ref_genome))[1:22]

# Make a rainfall plot
plot_rainfall(vcfs[[1]], title = names(vcfs[1]),
                chromosomes = chromosomes, cex = 1.5, ylim = 1e+09)
@

<<plot_rainfall, echo=FALSE>>=
# Define autosomal chromosomes
chromosomes <- seqnames(get(ref_genome))[1:22]

# Make a rainfall plot
ggsave("plot_rainfall.pdf",
       plot_rainfall(vcfs[[1]], title = names(vcfs[1]),
                     chromosomes = chromosomes, cex = 1.5, ylim = 1e+09),
       width=9,
       height=3)
@

\begin{figure}[H]
\begin{center}
\includegraphics[width=1.0\textwidth]{plot_rainfall}
\end{center}
\end{figure}

Also make rainfall plots for DBS and indels:

<<plot_rainfall_nosbs_noeval, eval = FALSE>>=
# Define autosomal chromosomes
chromosomes <- seqnames(get(ref_genome))[1:22]

# Make a rainfall plot
plot_rainfall(vcfs[[1]], title = names(vcfs[1]),
              chromosomes = chromosomes,
              type = c("dbs", "indel"),
              cex = 1.5, ylim = 1e+09)
@

<<plot_rainfall, echo=FALSE>>=
# Define autosomal chromosomes
chromosomes <- seqnames(get(ref_genome))[1:22]

# Make a rainfall plot
ggsave("plot_rainfall_dbs_indel.pdf",
       plot_rainfall(vcfs[[1]], title = names(vcfs[1]),
                     type = c("dbs", "indel"),
                     chromosomes = chromosomes, cex = 1.5, ylim = 1e+09),
       width=9,
       height=3)
@

\begin{figure}[H]
\begin{center}
\includegraphics[width=1.0\textwidth]{plot_rainfall_dbs_indel}
\end{center}
\end{figure}

% Make rainfall plot of the first sample over chromosome 1:
%
% \begin{figure}[H]
% \begin{center}
% <<plot_rainfall_2, fig=TRUE, width=6, height=3>>=
% chromosomes <- seqnames(get(ref_genome))[1]
% plot_rainfall(vcfs[[1]], title = names(vcfs[1]),
%                 chromosomes = chromosomes[1], cex = 2, ylim = 1e+09)
% @
% \end{center}
% \end{figure}

\subsection{Enrichment or depletion of mutations in genomic regions}

Test for enrichment or depletion of mutations in certain genomic regions, such
as promoters, CTCF binding sites and transcription factor binding sites.  To
use your own genomic region definitions (based on e.g. ChipSeq experiments)
specify your genomic regions in a named list of GRanges objects.  Alternatively,
use publicly available genomic annotation data, like in the example below.

\subsubsection{Example: regulation annotation data from Ensembl using
    \Biocpkg{biomaRt}}

The following example displays how to download promoter, CTCF binding sites and
transcription factor binding sites regions for
genome build hg19 from Ensembl using \Biocpkg{biomaRt}.  For other datasets,
see the  \Biocpkg{biomaRt} documentation \citep{Durinck2005}.

To install \Biocpkg{biomaRt}, uncomment the following lines:
<<install_biomaRt, eval=FALSE>>=
source("https://bioconductor.org/biocLite.R")
biocLite("biomaRt")
@

Load the \Biocpkg{biomaRt} package.
<<load_biomart>>=
library(biomaRt)
@

Download genomic regions. NB: Here we take some shortcuts by loading the results
from our example data. The corresponding code for downloading this data can be
found above the command we run:

<<download_using_biomaRt>>=
# regulatory <- useEnsembl(biomart="regulation",
#                          dataset="hsapiens_regulatory_feature",
#                          GRCh = 37)

## Download the regulatory CTCF binding sites and convert them to
## a GRanges object.
# CTCF <- getBM(attributes = c('chromosome_name',
#                             'chromosome_start',
#                             'chromosome_end',
#                             'feature_type_name',
#                             'cell_type_name'),
#              filters = "regulatory_feature_type_name",
#              values = "CTCF Binding Site",
#              mart = regulatory)
#
# CTCF_g <- reduce(GRanges(CTCF$chromosome_name,
#                 IRanges(CTCF$chromosome_start,
#                 CTCF$chromosome_end)))

CTCF_g <- readRDS(system.file("states/CTCF_g_data.rds",
                    package="MutationalPatterns"))

## Download the promoter regions and convert them to a GRanges object.

# promoter = getBM(attributes = c('chromosome_name', 'chromosome_start',
#                                 'chromosome_end', 'feature_type_name'),
#                  filters = "regulatory_feature_type_name",
#                  values = "Promoter",
#                  mart = regulatory)
# promoter_g = reduce(GRanges(promoter$chromosome_name,
#                     IRanges(promoter$chromosome_start,
#                             promoter$chromosome_end)))

promoter_g <- readRDS(system.file("states/promoter_g_data.rds",
                        package="MutationalPatterns"))

## Download the promoter flanking regions and convert them to a GRanges object.

# flanking = getBM(attributes = c('chromosome_name',
#                                 'chromosome_start',
#                                 'chromosome_end',
#                                 'feature_type_name'),
#                  filters = "regulatory_feature_type_name",
#                  values = "Promoter Flanking Region",
#                  mart = regulatory)
# flanking_g = reduce(GRanges(
#                        flanking$chromosome_name,
#                        IRanges(flanking$chromosome_start,
#                        flanking$chromosome_end)))

flanking_g <- readRDS(system.file("states/promoter_flanking_g_data.rds",
                                    package="MutationalPatterns"))
@

Combine all genomic regions (GRanges objects) in a named list:

<<combine_genomic_regions>>=
regions <- GRangesList(promoter_g, flanking_g, CTCF_g)

names(regions) <- c("Promoter", "Promoter flanking", "CTCF")
@

Use the same chromosome naming convention consistently:

<<combine_genomic_regions_2>>=
seqlevelsStyle(regions) <- "UCSC"
@

\subsection{Test for significant depletion or enrichment in genomic regions}

It is necessary to include a list with Granges of regions that were surveyed
in your analysis for each sample, that is: positions in the genome at which
you have enough high quality reads to call a mutation. This can
be determined using e.g. CallableLoci tool by GATK. If you would not include the
surveyed area in your analysis, you might for example see a depletion of
mutations in a certain genomic region that is solely a result from a low
coverage in that region, and therefore does not represent an actual depletion
of mutations.

We provided an example surveyed region data file with the package. For simplicity,
here we use the same surveyed file for each sample. For a proper analysis, determine
the surveyed area per sample and use these in your analysis.

Download the example surveyed region data:

<<download_bed_data>>=
## Get the filename with surveyed/callable regions
surveyed_file <- system.file("extdata/callableloci-sample.bed",
                             package = "MutationalPatterns")

## Import the file using rtracklayer and use the UCSC naming standard
library(rtracklayer)
surveyed <- import(surveyed_file)
seqlevelsStyle(surveyed) <- "UCSC"

## For this example we use the same surveyed file for each sample.
surveyed_list <- rep(list(surveyed), 9)
@

Test for enrichment or depletion of mutations in your defined genomic
regions using a binomial test.  For this test, the chance of observing a
mutation is calculated as the total number of mutations, divided by the
total number of surveyed bases.

<<genomic_distribution>>=
## Calculate the number of observed and expected number of mutations in
## each genomic regions for each sample.
distr <- genomic_distribution(vcfs, surveyed_list, regions, type = "all")
@

<<enrichment_depletion_test>>=
## Perform the enrichment/depletion test by tissue type.
distr_test <- enrichment_depletion_test(distr, by = tissue)
head(distr_test)
@

<<plot_enrichment_depletion_e, eval=FALSE>>=
plot_enrichment_depletion(distr_test)
@

\begin{figure}[H]
\begin{center}
<<plot_enrichment_depletion, fig=TRUE, width=7, height=5, echo=FALSE>>=
plot_enrichment_depletion(distr_test)
@
\end{center}
\end{figure}

\bibliography{references}

\section{Session Information}
<<sessionInfo, eval=TRUE, echo=FALSE, results=tex>>=
toLatex(sessionInfo())
@

\end{document}
